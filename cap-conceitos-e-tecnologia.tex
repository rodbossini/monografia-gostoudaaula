%% ------------------------------------------------------------------------- %%
\chapter{Conceitos e Tecnologia}
\label{cap:conceitos_e_tecnologia}

Neste capítulo abordamos os principais conceitos envolvidos durante o
desenvolvimento do projeto proposto. Além disso, um conjunto amplo de
tecnologias utilizadas atualmente no mercado foi empregado, o qual também é
descrito.

%% ------------------------------------------------------------------------- %%
\section{Conceitos}
\label{sec:conceitos}

Esta seção é dedicada a descrições detalhadas independentes de implementação
ou tecnologia sobre os principais conceitos envolvidos durante a elaboração
do projeto.\\ 



\subsection{Modelagem de Dados Conceitual}
\label{subsec:modelagem_de_dados_conceitual}

O desenvolvimento de um sistema computacional que utiliza armazenamento de dados
em meio persistente pode ocorrer de diversas formas. Uma possível abordagem, 
muito utilizada no mercado atualmente, consiste na elaboração de uma descrição 
sobre os dados com os quais a aplicação irá trabalhar. Essa descrição pode 
ser textual ou gráfica e ela é elaborada de forma independente de qualquer 
tecnologia. Em geral, ela é conhecida como modelo conceitual. A modelagem 
conceitual realizada neste trabalho é descrita no Capítulo~\ref{cap:projeto_tecnico}.

\subsection{Modelagem de Dados Relacional}
\label{subsec:modelagem_de_dados_relacional}
Uma vez obtida a descrição conceitual dos dados, a sua implementação pode ser
realizada de diferentes formas. Entre as mais utilizadas no mercado atual está 
a modelagem relacional, que consiste no uso de tabelas para o armazemamento dos
dados, além de diferentes restrições, como chaves primárias e estrangeiras.


Criar subseções para os seguintes itens: 
linguagem SQL e álgebra relacional (é só para descrever o que é, sem mostrar
código)
orientação a objetos
Mapeamento Objeto Relacional
Web Services
Dispositivos Móveis e aplicações


\section{Tecnologia empregada}
\label{sec:tecnologia_empregada}

Aqui teremos uma subseção para cada item de tecnologia utilizado, cada API, cada
linguagem etc. Conforme você descreve cada item, vá citando eles e adicionando à
bibliografia (arquivo bibliografia.bib). Siga o exemplo do JDK abaixo. Para cada
item basta escrver 3 ou 4 linhas.

\subsection{JDK - Java Development Kit}
\label{subsec:jdk}

O desenvolvimento de aplicações usando a linguagem Java requer o uso do
conhecido \emph{JDK - Java Development Kit}~\cite{jdk}, o qual pode ser obtido
gratuitamente a partir do link disponibilizado na bibliografia. Ele engloba,
entre outras coisas, uma implementação da linguagem Java, um compilador, um
ambiente de interpretação conhecido como máquina virtual Java etc. 

\subsection{Maven}
\label{subsec:maven}

A aplicação foi baseada na estrutura de um projeto maven. O maven é uma
biblioteca capaz de gerenciar projetos Java, com a finalidade de fazer
o \emph{build} (construção) do projeto resolvendo os problemas de: gerenciamento de
dependência, deploy, modularização de projeto, testes e controle de versão do
projeto. O Maven permite o build do projeto utilizando o \emph{Project Object
Model} (POM). O POM é um arquivo XML que descreve todas as informaçõees que o
projeto Maven possui, como por exemplo, lista de dependências, configurações de
plugins, profiles entre outras iformações que o projeto possa ter. A partir do
pom.xml, podemos configurar todas as propriedades para indicar como o Maven se
comportará.

\subsection{Gerenciamento de dependência}
\label{subsec:gerenciamento_de_dependência}

Durante o desenvolvimento da aplicação, utilizamos outras APIs
para resolver determinados problemas, como por exemplo, o Spring, Hibernate,
Jackson entre outros. Todas as essas APIs são arquivos .jar que precisam ser
baixadas e adicionadas ao projeto, porém, quando fazemos isso manualmente, nem
sempre é uma terá simples e tende apresentar problemas, como por exemplo o
Hibernate que, além de precisar das bibliotecas próprias, precisa da API da JPA.
O Maven resolve todos esses problemas simplesmente adicionando a dependência por
meio da tag <denpendency>: 

\begin {lstlisting}
<properties>
	//outras propriedades
	<hibernate.version>4.3.11.Final</hibernate.version>
</properties>

<dependencies>
	//outras dependências
	<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
	</dependency>
<dependencies>

\end{lstlisting}
\captionof{lstlisting}{Adicionando o hibernate para a o projeto usando o
pom.xml}

\subsection{Deploy}
\label{subsec:deploy}

Todas as vezes que terminamos uma funcionalidade ou até mesmo finalizamos a
aplicação, precisamos distribuir essa aplicação para uso, ou seja, publicá-la
ou, tecnicamente falando, fazer o deploy. Em muito dos casos, fazer o deploy da
aplicação nem sempre é uma tarefa trivial, pois é necessário se preoculpar com
ambientes diferentes, por exemplo, em ambiente de desenvolvimento, nós
podemos utilizar um banco de dados de teste, podemos utilizar qualquer versão do
JDK entre outras tarefas que não impactam o cliente, porém em um ambiente de
produção precisamos evitar o máximo possível de bugs, ou seja, tomar cuidado com
qual tipo de configuração a nossa aplicação está utilizando. Cuidar manualmente
desse tipo de rotina permite um risco maior de falhas causando problemas que
poderiam ser evitados, como por exemplo, utilizar um usuário e senha de banco de
dados que não existe no servidor externo, e é justamente por esses motivos que
podemos utilizar os \emph{profiles} do Maven que são capazes de criar diferentes
perfis para cada tipo de ambiente por meio da tag <profile> segue um exemplo de
uma configuração para ambiente de desenvolvimento e para ambiente de produção:

\begin{lstlisting}
<profiles>

		<profile>
			<id>Development</id>
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
			<properties>
				/*podemos adicionar todas as 
				propriedades para ambiente de desenvolvimento*/
			</properties>
		</profile>

		<profile>
			<id>openshift</id>
			<activation>
				<activeByDefault>false</activeByDefault>
			</activation>
			<properties>
				/* podemos adicionar todas as 
				propriedades para o ambiente de
				produção, nesse caso o openshift */
			</properties>
			<build>

				<finalName>gostoudaaula</finalName>
				<plugins>
					<plugin>
						<artifactId>maven-war-plugin</artifactId>
						<version>2.1.1</version>
						<configuration>
							<outputDirectory>webapps</outputDirectory>
							<warName>ROOT</warName>
						</configuration>
					</plugin>
				</plugins>
			</build>
		</profile>
	</profiles>
\end{lstlisting}
\captionof{lstlisting}{Criando profiles para ambiente de desenvolvimento e
ambiente de produção no pom.xml}


Além de configurar diferentes perfis da aplicação, o Maven também executa uma
rotina em que verifica se todo o projeto está funcionando da maneira correta,
por exemplo, verifica se todas as bibliotecas e APIs que foram descritas no
pom.xml estão funcionando corretamente, faz todos os testes que foram realizados
no projeto para garantir se todos funcioram e também gera os arquivos de deploy,
ou seja, arquivos .jar para aplicações Java e arquivos .war para aplicações
Java Web.

\subsection{Modularização de projeto}
\label{subsec:modularização_de_projeto}

O desenvolvimento da aplicação foi baseado em módulos, isso significa que
existe mais de um projeto que resolve um problema em específico, por exemplo,
existe o projeto gostoudaaula-core que possui todas as classes modelos da
aplicação, o projeto gostoudaaula-db que possui todas as classes que cuidam da
lógica de banco de dados e o projeto gostoudaaula-web que é a aplicação web em
si. Podemos fazer uso desse tipo de arquitetura por meio dos módulos do Maven. 
Para criarmos módulos no Maven precisamos primeiro criar um projeto do Maven que
chamando de parent, esse projeto será o projeto principal da aplicação, ou seja,
iremos incluir todos os demais projetos dentro dele. Na aplicação foi criado o
projeto gostoudaaula-parent. A figure 2.1 demonstra a estrutura do projeto
parent:

\begin{figure}
\includegraphics{projeto-parent.png}
\caption{Estrutura do projeto parent}
\end{figure}

Para adicionar módulos para esse projeto, precisaremos criar novos projetos
Maven dentro desse projeto e então precisamos incluir o nome desses na tag <module>:

\begin{lstlisting}
	<modules>
		<module>
			gostoudaaula-core
		</module>
		<module>
			gostoudaaula-web
		</module>
		<module>
			gostoudaaula-db
		</module>
	</modules>
\end{lstlisting}
\captionof{lstlisting}{Exemplo para associar os projetos como módulos no
pom.xml}

Nesse exemplo estamos indicando que os projetos citados serão os módulos do
projeto parent, porém ainda precisamos especificar aos módulos quem será o
parent, então adicionamos a tag <parent> no pom.xml:

\begin{lstlisting}
	<parent>
		<groupId>br.com.gostoudaaula</groupId>
		<artifactId>gostoudaaula-parent</artifactId>
		<version>//versão</version>
	</parent>
\end{lstlisting}
\captionof{lstlisting}{Exemplo de como informar qual é o parent do modulo no
pom.xml}

\subsection{Testes com TDD}
\label{subsec:testes_com_TDD}

O desenvolvimento das funcionalidades da aplicação, foi baseado na prática do
TDD (Test Driven Development) que tem a finalidade de fazer com que o
desenvolvedor crie primeiro o cenário de teste e então desenvolva a
funcionalidade, por exemplo, suponhamos que precisamos criar uma funcionalidade
que precise cadastrar um aluno no banco de dados, quando utilizamos o TDD
criamos um método responsável por testar essa funcionalidade que a aplicação
precisa, para implementar esses testes utilizamos o framework JUnit que fornece
anotações específicas para realizar testes no Java.
Esse método precisa ser escrito de uma forma bem explícita sobre o que está sendo testado, para esse caso poderíamos escrever o
seguinte método:

\begin{lstlisting}

	@Test
	public void deveCadastrarUmAluno(){
		//implementação que precisa ser testada
	}
	
\end{lstlisting}
\captionof{lstlisting}{Exemplo de um caso de teste utilizando o JUnit}

E então montamos o cenário para que esse teste seja realizado, como por
exemplo, chamar todas as classes necessárias para executar o teste. A ideia em
implementar o TDD, consiste na intenção de gerar uma pilha de testes que serão
executados constantemente, para garantir que a aplicação está sempre funcionando
conforme o esperado, mesmo que implemetemos novas funcionalidades, por exemplo,
se precisarmos adicionar mais uma rotina nova para cadastrar um aluno,
executamos novamente o teste que fizemos e verificamos se ainda funciona como o
esperado.

\subsection{Spring framework}
\label{subsec:spring_framework}

O Spring framework é um conjunto de módulos (projetos) em que tem a finalidade
de resolver diversos problemas que são comuns em uma aplicação web, na aplicação foi
utilizado para resolver as questões de controle de transações e injenção de
dependência.

\subsection{Injecão de dependência}
\label{injeção_de_dependência}

Durante o desenvolvimento da aplicação, foi utilizado uma grande quantidade de
bibliotecas e APIs, porém, em Java, ou em qualquer tipo de aplicação orientada a
objetos, sempre que queremos utilizar uma classe, precisamos fazer uma
instância, no caso de APIs, além de fazer uma instância, na maioria das vezes,
precisamos realizar certas configurações para que funcione de acordo com a nossa
necessidade. O Spring framework fornece para nós um recurso conhecido como
injeção de dependência, que consiste em atribuir uma instância a um
objeto automaticamente. Quando queremos que um objeto seja injetado, utilizamos
a anotação @Inject, que indica que o objeto será injetado:

\begin{lstlisting}

	@Inject
	private Aluno aluno;
	
\end{lstlisting}

\subsection{Inversão de controle}
\label{subsec:inversão_de_controle}

A injeção de dependência atribuirá as instâncias necessárias para os objetos que
estão anotados com @Inject, porém, para que o Spring consiga injetar esses
objetos, precisamos ensinar o Spring a criar essas instâncias. Quando ensinamos
o Spring a criar instâncias, podemos configurar como a instância será criada e
então o Spring passa a gerenciar todas as classes que estão anotadas com
@Inject, fazendo com que o programador não precise mais se preocupar em
instânciar esses objetos, essa abordagem de fazer com que o framework instancie
os objetos é chamada de Inversão de Controle (IoC).

\subsection{Beans do Spring}
\label{subsec:beans_do_spring}

Quando ensinamos o Spring a instanciar uma classe, essa classe se tornará um
\emph{Bean} do Spring. Os Beans do Spring são todas as classes gerenciadas pelo
ele, ou seja, serão todas as classes que o Spring saberá criar as instâncias.
Para transformarmos uma interface ou classe em um bean, basta adicionar uma
tag <bean> no arquivo XML de configuração do spring:

\begin{lstlisting}
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">
    
	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		
	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	//para adicionar mais beans, adicione mais tags <bean> e ensine como a classe
	precisa ser instanciada

</beans>
\end{lstlisting}

\subsection{controle de transações}
\label{subsec:controle_de_transações}

Para conectar a aplicação com o banco de dados, foi utilizada a especificação
JPA (Java Persistence API) que estabalece uma comunição com o banco de dados
criando transações. Porém, todas as vezes que estamos utilizando uma transação
precisamos saber o momento em que ela precisa ser iniciada e o momento em ela
precisa aplicar as ações de commit/rollback e por fechá-las. Perceba que essa
ações podem ser um pouco repitivas como também perigosas para a nossa aplicação,
como por exemplo, interagir com o banco por meio de uma transação e não
realizar o commit, ou então, simplesmente não fechar a conexão. Devido a esses
detalhes, utilizamos o Spring para fazer a injeção de dependência das classes
que são responsáveis em lidar com as transações, ou seja, o Spring gerencia
todas as transações da aplicação, garantindo que todas essas rotinas sejam
feitas corretamente sem o desenvolvedor precisar se preocupar.

\subsection{openshift}
\label{subsec:openshift}

O openshift é uma plataforma como um serviço, também
conhecido por PaaS (Platform-as-a-Service), da Red Hat que permite o os
desenvolvedores a criar um host e fazer o deploy da aplicação em um ambiente na
nuvem.

\subsection{web console}
\label{subsec:web_console}

O openshift fornece um web console em uma interface gráfica para criar as
aplicações desejadas, como por exemplo, criar uma aplicação Java web utilizando
o tomcat ou o Jboss.

\subsection{configurando o openshift}
\label{subsec:configurando_o_openshift}

A configuração foi feita no sistema linux e distribuição Ubuntu. Para os
sistemas operacionais, pode consultar o link do próprio openshift:
https://developers.openshift.com/en/getting-started-overview.html.

\subsection{instalação via dpkg}
\label{instalação_via_dpkg}

Para integrar um computador remoto com o ambiente do openshift, precisamos
instalar o Openshitf client tools (rhc). Utilize o terminal do linux e digite:

\begin{lstlisting}
$ sudo apt-get install rhc
\end{lstlisting}

\subsection{instalação do git}
\label{subsec:instalação_do_git}

O Openshift trabalha com o git para fazer deploy da aplicação, então precisamos
instalar o git também. Utilize novamente o terminal do linux e digite:

\begin{lstlisting}
$ sudo apt-get install git-core
\end{lstlisting}

Após terminar a instalação, verifique a versão do git com o comando:

\begin{lstlisting}
$ git --version
\end{lstlisting}

\subsubsection{configurando o Openshift client tools}
\label{subsec:configurando_o_openshift_client_tools}

Utilizando novamente o terminal do linux digite o comando

\begin{lstlisting}
$ rhc setup
\end{lstlisting}

Será solicitado o e-mail e senha cadastro no openshift, digite e aperte enter.
Na configuração perguntará se é necessário criar uma chave pública para poder
identificá-lo sem precisar informar o usuário e senha a cada commit, caso quiser
aceite. 

\subsection{Utilizando o Openshift client}
\label{subsec:utilizando_o_openshift_client}

Após a instalação do openshift, podemos baixar a aplicação utilizando o git,
basta fazer o clone da url que será disponibilizada no web console. Por padrão
será devolvido um arquivo chamado .openshift que tem algumas configurações do
openshift, basta manter esse arquivo e adicionar a aplicação nesse repositório
do git e então fazer um push.





