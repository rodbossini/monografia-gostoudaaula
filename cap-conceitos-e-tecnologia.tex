%% ------------------------------------------------------------------------- %%
\chapter{Conceitos e Tecnologia}
\label{cap:conceitos_e_tecnologia}

Neste capítulo abordamos os principais conceitos envolvidos durante o
desenvolvimento do projeto proposto. Além disso, um conjunto amplo de
tecnologias utilizadas atualmente no mercado foi empregado, o qual também é
descrito.

%% ------------------------------------------------------------------------- %%
\section{Conceitos}
\label{sec:conceitos}



Esta seção é dedicada a descrições detalhadas independentes
de implementação ou tecnologia sobre os principais conceitos envolvidos durante a elaboração
do projeto. 

\subsection{Modelagem de Dados Conceitual}
\label{subsec:modelagem_de_dados_conceitual}

O desenvolvimento de um sistema computacional que utiliza armazenamento de dados
em meio persistente pode ocorrer de diversas formas. Uma possível abordagem, 
muito utilizada no mercado atualmente, consiste na elaboração de uma descrição 
sobre os dados com os quais a aplicação irá trabalhar. Essa descrição pode 
ser textual ou gráfica e ela é elaborada de forma independente de qualquer 
tecnologia. Em geral, ela é conhecida como modelo conceitual. A modelagem 
conceitual realizada neste trabalho é descrita no
capítulo~\ref{subsec:jpa_java_persistence_api}.

\subsection{Modelagem de Dados Relacional}
\label{subsec:modelagem_de_dados_relacional}
Uma vez obtida a descrição conceitual dos dados, a sua implementação pode ser
realizada de diferentes formas. Entre as mais utilizadas no mercado atual está 
a modelagem relacional, que consiste no uso de tabelas para o armazemamento dos
dados, além de diferentes restrições, como chaves primárias e estrangeiras.

\subsection{SQL e álgebra relacional}
\label{subsec:sql_e_algebra_relacional}

Structured Query Language (linguagem de consulta estruturada) é uma linguagem de
pesquisa padrão para banco de dados relacionais, onde permite a comunicação com
um banco de dados para a realização de consultas simples ou com álgebra
relacional. A álgebra relacional é uma teoria onde é representada,
matematicamente, a forma como podemos manipular as consultas realizadas
utilizando o SQL, como por exemplo, mencionar quais são os atributos e filtros que necessários com o intuito de devolver o resultado
esperado.

\begin{equation}
	\sigma_{id = 1} (Empregado)
\end{equation}

\subsection{Orientação a objetos}
\label{subsec:orientacao_a_objetos}

O paradigma de POO (programação orientada a objetos) é um modelo para o
desenvolvimento de software ao qual utilizamos unidades chamadas de
objetos. Esse paradigma nos permite modelar um sistema
computacional por meio desses objetos que representam todas as entidades
contidas no sistema que, por sua vez, refletem as características de um
objeto da vida real para a aplicação, como por exemplo, na modelagem
dessa aplicação, foi necessário modelar a entidade aula que representa uma aula
da vida real que compõe um aluno, um professor e qualquer outra informação que seja necessária
para essa entidade.

Os objetos dessas entidades são identificados como classes que possuem estados
(atributos) e comportamentos (métodos) que definem suas responsabilidades e
razão de existir. Em código, podemos representar as classes conforme o exemplo
do Código~\ref{lst:classes_aula_professor_e_aluno}.

\begin {lstlisting}[caption={Exemplo de como podemos criar 3 classes e adicionar seus
atributos}, label = {lst:classes_aula_professor_e_aluno}]
class Aula {
	
	Aluno aluno;
	Professor professor;
	
	//atributos e métodos
	
}

class Professor {
	
	List<Aula> aulas;
	
	//atributos e métodos
	
}

class Aluno {
	
	List<Aula> aulas;
	
	//atributos e métodos
	
}
\end{lstlisting}

Nesse exemplo, são representadas 3 classes, ou seja, a classe Aula que contém
um aluno e um professor, a classe Professor que contém aulas e a classe Aluno
e contém aulas.\\

Além disso, na POO, temos grandes benefícios devido aos
recursos de encapsulamento~\ref{subsubsec:encapsulamento},
herança~\ref{subsubsec:heranca}, polimorfismo~\ref{subsubsec:polimorfismo} que permitem
o desenvolvimento de um sistema mais coerente, seguro e manutenível.

\subsubsection{Encapsulamento}
\label{subsubsec:encapsulamento}

O encapsulamento é um recurso que tem o objetivo de esconder todos os passos que
são realizados em uma chamada de método. Podemos verificar um pequeno
exemplo de encapsulamento durante uma chamada a partir do
Código~\ref{lst:utilizacao_encapsulamento}:

\begin{lstlisting}[caption={Exemplo de utilização do encapsulamento para
calcular um bonus}, label = {lst:utilizacao_encapsulamento}]
class CalculadoraDeBonus {

	double calcularBonus(double salario){
		if(salario < 1000){
			return salario * 0.15;
		} else {
			return salario * 0.10;
		}
	}
	
	//atributos e métodos

}

class Funcionario {

	double salario;
	double bonus;
	
	double getBonus(){
		bonus = new CalculadoraDeBonus().calcularBonus(this.salario);
		return bonus;
	}

}

\end{lstlisting}

Observe que a classe \lstinline{Funcionario} possui os atributos
\lstinline{salario} e \lstinline{bonus} e o método \lstinline{getBonus()}.
Quando alguém, que não seja a classe \lstinline{Funcionario} chamar o método
\lstinline{getBonus()}, saberá como esse bonus é calculado? A resposta é não!
Pois todos os passos, procedimentos ou qualquer que seja a rotina realizada para
calcular o bonus está escondida! Além disso, observe que a classe
\lstinline{Funcionario} faz uma chamada ao método \lstinline{calcularBonus(double salario)} que também possui seus procedimentos, ou seja, passos que nem mesmo a
classe \lstinline{Funcionario} sabe, ou seja, outro exemplo de encapsulamento! É
fácil compreender que o encapsulamento é justamente esconder o código para que
todos que o chamem, não precisem saber como funciona por de trás dos panos,
porém, quais são os benefícios que temos ao utilizá-lá? 


\begin{itemize}
\item Segurança.
\begin{itemize}
\item Não exibir como tudo é feito por de trás dos panos.
\item Não permitir que alterem qualquer valor que esteja dentro do método.
\end{itemize}
\item Manutenabilidade.
\begin{itemize}
\item Se um dia os procedimentos, passos ou qualquer parte do código
encapsulada precisarem ser alterados(as), basta apenas alterar dentro de um
único método.
\end{itemize}
\item Reutilização de código.
\begin{itemize}
\item Permite a possibilidade de reutilizar o mesmo código, exigindo apenas uma
chama à função que encapsulou todo algoritmo.
\end{itemize}
\end{itemize}

\subsubsection{Herança}
\label{subsubsec:heranca}

A herança é um dos principais recursos da orientação a objetos, pois, por meio
dela, podemos criar classes filhas de uma classe. Quando dizemos que uma classe
é filha de outra, significa que a classe filha herda todos os atributos e
métodos da classe mãe, ou seja, ela possuirá o mesmo comportamento que sua
classe mãe, porém, ela também terá os seus próprios comportamentos. Por exemplo,
na aplicação, foi realizada a abstração de um usuário qualquer no sistema, o
resultado obtido dessa abstração foi a classe \lstinline{Usuario} conforme o
Código~\ref{lst:classe_usuario}:

\begin{lstlisting}[caption={Exemplo de uma classe que representa um usuário no
sistema}, label = {lst:classe_usuario}]
public class Usuario {
	
	long id;
	String senha;
	String nome;
	String sobrenome;
	
	//métodos e atributos
	
}
\end{lstlisting}

Como podemos ver, essa classe pode representar qualquer usuário dentro da
aplicação. Porém, nessa aplicação, existem 2 tipos de usuários, que são os
alunos e professores, que consequentemente, possuem comportamentos diferentes no
sistema, mas, além de suas diferenças, eles possuem semelhanças que são os
atributos id, senha, nome, sobrenome ou qualquer outro tipo de comportamento ou
estado que é esperado de qualquer usuário. 

Temos diversas formas de resolver essa distinção dentro de um sistema
computacional, porém, uma das soluções possíveis e sofisticada dentro da orientação a objetos, é fazer com que a classe
\lstinline{Professor} e \lstinline{Aluno} herdem da classe \lstinline{Usuario},
pois, dessa forma, faremos com que ambas possuam os mesmo comportamentos de um
usuário qualquer, mas, que cada uma tenha o seu próprio comportamento dentro da
aplicação. Para fazer com que uma classe herde de outra, basta utilizar a
instrução \lstinline{extends}, onde é possível visualizar o exemplo a partir do
Código~\ref{lst:heranca_usuario_aluno_professor}:

\begin{lstlisting}[caption={Exemplo de como criamos classes filhas utilizando a
herança do Java}, label = {lst:heranca_usuario_aluno_professor}]
public class Usuario {
	
	long id;
	String senha;
	String nome;
	String sobrenome;
	
	//métodos e atributos
	
}

public class Aluno extends Usuario {

	//atributos, métodos
	 
}

public class Professor extends Usuario {

	//atributos, métodos
	 
}
\end{lstlisting}

A partir do momento em que as classes \lstinline{Aluno} e \lstinline{Professor}
estendem da classe \lstinline{Usuario}, significa que, além de representarem
elas mesmos dentro da aplicação, elas também são um usuário, ou seja, a partir
desse momento, qualquer comportamento e estado que estiver na classe
\lstinline{Usuario}, serão herdados por essas classes também.

\subsubsection{Polimorfismo} 
\label{subsubsec:polimorfismo}

Um dos principais pontos da herança em orientação a objetos, é a questão em que,
uma classe filha reutilize um comportamento herdado, porém, que precise de
alguma moficação peculiar daquela classe, por exemplo, imaginemos que a classe
\lstinline{Usuario} contenha o método \lstinline{cadastrarSenha(String senha)},
esse método, dentro da classe \lstinline{Usuario} possui um processo de
criptografia padrão, e para a classe professor, precisa utilizar um padrão
diferente ao qual um usuário qualquer use.\\

Para que isso seja
possível, ou seja, utilizar a mesma assinatura de método
(\lstinline{cadastrarSenha(String senha)}) para com um comportamento diferente,
reescrevemos o método da classe \lstinline{Usuario} (classe mãe) dentro da classe \lstinline{Professor} (classe filha) e adicionamos o comportamento específico e esperado daquele método para a classe \lstinline{Professor}, veja o exemplo a partir do
Código~\ref{lst:usuario_professor_polimorfismo}:

\begin{lstlisting}[caption={Exemplo de polimorfismo da classe filha Professor e
classe mãe Usuario}, label = {lst:usuario_professor_polimorfismo}]
class Usuario {

	public cadastrarSenha(String senha){
		//passos e rotinas da classe Usuario
	}

}

class Professor extends Usuario {

	@Override
	public cadastrarSenha(String senha){
		//passos e rotinas da classe Professor
	}

}
\end{lstlisting}

Note que foi utilizada uma \emph{annotation} do Java~\cite{annotations} que
indica que o método pertence a uma classe mãe, porém ele está sendo sobrescrito, ou seja, ele terá
um comportamento diferente do padrão.

\subsection{ORM - Object Relational Mapping}
\label{subsec:orm_object_relational_mapping}

Mapeamento Objeto Relacional (ORM - Object Relational Mapping) é uma técnica que
permite a persistência em um banco de dados utilizando o paradigma orientado a
objeto. Isso significa que as entidades de um banco de dados podem ser
representadas por meio de classes e seus atributos. A utilização dessa
técnica para o desenvolvimento de um sistema computacional deve-se à facilidade
que um programador tem ao desenvolver um sistema que exija uma comunicação
constante com o banco de dados, pois ele não precisa obter um alto conhecimento
de SQL ou banco de dados para conseguir realizar consultas, persistências,
alterações dados ou qualquer tipo de ação que o banco de dados e a aplicação
terão. A aplicação desse conceito no Java, é descrita com mais na seção
~\ref{subsec:jpa_java_persistence_api}.

\subsection{Web Services}
\label{subsec:web_services}

Os serviços na web é uma solução muito utilizada no mercado para permitir que
diversas aplicações, independentemente da plataforma em que foram desenvolvidas,
consigam se comunicar com o sistema via um protocolo de rede em comum, como
por exemplo o HTTP~\cite{http}. Essa comunicação é permitida devido ao tipo de
mensagem/documento que é processado para enviar e receber os dados, como por
exemplo, arquivos no formato XML~\cite{xml} ou JSON~\cite{json}. Além de
permitir a comunicação entre diversas aplicações, os web services tem o intuito de disponibilizar serviços
que são acessíveis por meio de endereços públicos da aplicação, também
conhecidos por API (Application Programmer Interface).

\subsubsection{REST}
\label{subsubsec:rest}

Representational State Transfer (REST), no português Transferência de Estado
Representacional, é uma abstração arquiteturial para comunicação na Web
frequentemente utilizada em Web Services~\ref{subsec:web_services}. Uma de suas
aplicações dentro de um Web Services é a distribuição de APIs. Essa arquitetura
utiliza o protocolo de comunição HTTP e utiliza como notação comum para
transferência de dados tanto o XML como JSON.

\subsection{Dispositivos Móveis e Aplicações}
\label{subsec:dispositivos_moveis_e_aplicacoes}

Segundo o relatório do International Data Corporation (IDC) publicado
em maio de 2012, o Android possui 59\% do mercado de smartphones e soma
a quantia de 89,9 milhões de aparelhos distribuídos apenas no primeiro tri-
mestre deste ano (2012), em todo o mundo. Em segundo lugar, aparece o iOS
que é o sistema operacional do Apple iPhone. O gráfico 1.1 demonstra a par-
ticipação no mercado dos principais sistemas operacionais e a quantidade de
aparelhos distribuídos.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{grafico_android_2012.png}
  \caption{Participação no mercado. Fonte: IDC ~\cite{jbmonteiro:12}}
  \label{fig:grafico_android_2012}.
\end{figure}

O IDC também prevê que, em 2016, o Android ainda possuirá a maior
fatia do mercado, com 52,9\%. A disputa pelo segundo lugar será acirrada
entre iOS e Windows Phone 7. A ~\ref{fig:grafico_android_2012} ilustra a
previsão realizada pelo IDC.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{grafico_android_2016.png}
  \caption{Previsão do mercado para 2016. Fonte: IDC
  ~\cite{jbmonteiro:12}}
  \label{fig:grafico_android_2016}
\end{figure}

Já no mercado de tablets, o iPad detém o trono com 68\% , enquanto o
Google aposta em seu primeiro tablet, o Nexus 7 ao preço US\$199,00, para
ga- nhar terreno tentando repetir o sucesso do Amazon Kindle Fire, que também
utiliza Android.

\subsection{MVC - Model View Controller}
\label{subsec:mvc_model_view_controller}

O modelo MVC consiste em dividir a aplicação em camadas, onde é possível
representar um sistema computacional completo em 3 camadas distintas de uma
forma macro. Abaixo, estão listadas tais cadamas e seus objetivos
respectivamente:

\begin{itemize}
  \item \textit{\textbf{Model:}} Representa toda a regra de negócio da
  aplicação, ou seja, todas as classes, configuração, acessos à base de dados
  ou qualquer recurso que esteja do lado do servidor e que o usuário final não tenha acesso.
  \item \textit{\textbf{View:}} Todo conteúdo que representa a parte visual da
  aplicação, ou seja, qualquer interface com o usuário.
  \item \textit{\textbf{Controller:}} É o responsável em receber todas as
  requisições do usuário (\emph{View}) direcionar à aplicação o que foi solicitado
  (\emph{Model}) e por fim, enviar uma resposta ao usuário.
\end{itemize}

A partir da Figura~\ref{fig:mvc}, é possível representar de forma visual todo o
conceito proposto:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{mvc.png}
  \caption{Diagrama que representa conceitualmente o mvc a partir de um
  navegador qualquer} \label{fig:mvc}.
\end{figure}

A partir dessa arquitetura, podemos desenvolver uma aplicação de uma
forma mais organizada e segura, pois além de dividirmos todo o conteúdo de acesso ao
usuário (páginas em HTML~\cite{html} ou qualquer interface direta ao usuário) e
a regra de negócio (classes, configurações, acesso aos dados ou qualquer parte interna do
sistema) deixamos transparente como tudo funciona internamente, ou seja, o
usuário enxerga apenas o que ele precisa saber sem ter noção alguma de como é o
sistema internamente.

\subsection{TDD - Test Driven Development}
\label{subsec:tdd_test_driven_development}

O desenvolvimento das funcionalidades da aplicação, foi baseado na prática do
TDD (Test Driven Development) que tem a finalidade de fazer com que o
desenvolvedor crie primeiro o cenário de teste e então desenvolva a
funcionalidade, por exemplo, suponhamos que precisamos criar uma funcionalidade
que precise cadastrar um aluno no banco de dados, quando utilizamos o TDD
criamos um método responsável por testar essa funcionalidade que a aplicação
precisa.\\

O principal objetivo da utilização do TDD é garantir que a aplicação contenha
menos bugs, pois ao invés de implementar a aplicação toda para depois testá-la,
implementamos ``pedaços'' da aplicação e então testamos esses pedaços, ou seja, 
implementamos o código necessário para realizar o teste que precisamos, por
exemplo, se precisamos cadastrar um aluno no sistema ou verificar se o login
funciona como o esperado, implementamos cada uma dessas funcionalidades da forma
mais simples possível apenas para serem testadas. A diferença entre testar
pedaços da aplicação ao invés da aplicação num todo, é que permitimos que a nossa aplicação seja mais coerente, 
segura e flexível, pois implementaremos métodos pequenos e com apenas uma
responsabilidade, dessa forma garantimos que a funcionalidade esteja funcionando
,e então, permitimos que ela seja reutilizada em qualquer parte do código sem
preocupações de falhas. Além disso, se um dia precisarmos realizar alguma
alteração de uma funcionalidade, alteraremos apenas em um ponto do sistema. \\

Como podemos ver, a prática do TDD, além de nos ajudar a garantir um sistema
mais confiável, tende a criar diversos cenários dentro da aplicação, aumentando
muito mais o tempo de desenvolvimento do sistema. A princípio parece uma prática
que mais atrapalha do que ajuda o desenvolvimento, porém, quando estamos desenvolvendo, é muito comum que ocorra muitas mudanças no código
e nem sempre conseguimos prever o quão impactante foi a alteração, ou seja, se
ainda funciona ou se quebrou o nosso sistema.\\ 

Sem a utilização do TDD, inicialmente, pensamos em \textbf{testar manualmente
tudo novamente} para verificar se ocorreu algum problema após alguma alteração
realizada no sistema.
Além de ser trabalhoso, provavelmente, esqueceremos de testar todas as funcionalidades do sistema, ou seja, a chance de não garantir que tudo esteja funcionando como o esperado, é muito grande. Quando utilizamos o TDD, todos os cenários de testes que criamos
são testados automaticamente, como uma \emph{pilha de processos}, dessa forma,
evitamos perder tempo em verificar manualmente cada cenário e, se algum teste falhar, a
nossa própria aplicação mostratará o que e onde falhou com muito mais precisão.
\\

Para utilizarmos o conceito de TDD em Java, podemos fazer uso da API JUnit
que é descrita com mais detalhes no capítulo ~\ref{subsec:testes_JUnit}.

\subsection{Aplicações cliente e servidor}
\label{subsec:cliente_e_servidor}

Em aplicações Web, como por exemplo websites, é muito comum encontrarmos a
arquitetura de aplicação conhecida como \emph{cliente e servidor}, que é
justamente uma aplicação autônoma (servidor) que recebe diversas requisições de
diversos usuários (cliente) e responde de acordo com o que cada cliente
requisitou, como por exemplo, se um cliente solicita uma página de cadastro, o
servidor recebe essa requisição, executa os passos necessários e
responde com a página solicitada.

\subsection{Servidor de aplicação}
\label{subsec:servidor_de_aplicacao}

Em aplicações Web, é muito comum utilizarmos um servidor que será responsável em
manter a aplicação ativa. Esses servidores são conhecidos como servidores de
aplicação. A principal responsabilidade desses servidores, é
manter as aplicações disponíveis, ou seja, mantê-las funcionando para que seja
possível, por exemplo, receber requisições dos clientes e respondê-las
~\ref{subsec:cliente_e_servidor}.

\subsection{UML - Unified Modeling Language}
\label{subsec:uml}

O UML - Unified Modeling Language, na tradução, Linguagem Unificada de
Modelagem, é uma linguagem de modelagem que permite representarmos um sistema de
forma padronizada utilizando o conceito de orientação a objetos. A importância
da utilização da UML é justamente para esclarecer o comportamento da aplicação
tanto para a equipe de desenvolvimento quanto para o cliente. No UML, tais
padrões são representados a partir de diagramas, onde é possível enxerga de
forma visual as características do sistema.

\subsubsection{Diagrama de classes}
\label{subsubsec:diagrama_de_classes}

Utilizamos o diagrama de classes para representar todas as principais
classes do nosso sistema, com seus nomes, atributos e métodos e relacionamentos, em
outras palavras, quando utilizamos o diagrama de classes, exibimos de uma forma
mais ampla, ou seja, sem uma especificação independemente da implementação,
linguagem de programação, que será utilizada. 

\subsubsection{Diagrama de caso de uso}
\label{subsubsec:diagrama_de_caso_de_uso}

No diagrama de caso de uso, podemos demonstrar as principais funcionalidades e
seus atores dentro da aplicação, por exemplo, dentro da
aplicação, \textbf{realizar o login} pode ser feito tanto por um
\textbf{professor}, quanto para um \textbf{aluno}. Seguindo esse pequeno
exemplo, identificamos que, realizar o login é uma funcionalidade da aplicação,
e que os atores são o aluno e o professor. 

\subsubsection{Diagrama de sequência}
\label{subsubsec:diagrama_de_sequencia}

O diagrama de sequência é utilizado para descrever com mais detalhes o fluxo de
uma funcionalidade, por exemplo, a funcionalidade \textbf{realizar o login} dos
autores \textbf{aluno} ou \textbf{professor}, ambos enviam suas credenciais para
o servidor, o servidor consulta as credenciais no banco de dados e, se tudo
estiver correto, ele responde com as informações do aluno/professor junto com o
um token identificador. O diagrama de sequência não é utilizado em todas as
funcionalidade, em outras palavras, a intenção do diagrama de sequência é
justamente dar mais atenção às funcionalidades mais peculiares da aplicação e
que exigem uma certa atenção tanto para o cliente quanto para os
desenvolvedores.

\subsection{Migration de banco de dados}
\label{subsec:migration_de_banco_de_dados}

Quando desenvolvemos uma aplicação, em alguns momentos temos a necessidade de
realizar algumas alterações na estrutura do banco de dados, como por exemplo a
adição ou alteração ou, em casos mais delicados, a exclusão de uma coluna ou tabela. Tais
modificações precisam ser gerenciadas e mantidas para todas as versões de
desenvolvimento do banco de dados antes mesmo de realizar o
deploy~\ref{subsubsec:distribuicao_da_aplicacao_deploy}, pois se uma versão for
diferente, o desenvolvedor que realizar o deploy com a versão diferente pode
causar diversos problemas inesperados em um ambiente de produção.\\

Gerenciar esses eventos dentro de um projeto, isto é, a realização do controle
para que todos mantenham a mesma versão do banco atual com as existentes em
diversas ramificações do projeto, tecnicamente é chamado de \textit{migration}.
Nesse projeto, todo o processo de migration de banco de dados para esse projeto, 
foram gerenciadas a partir da biblioteca flyway~\ref{subsec:flyway}.

\subsection{Versionamento}
\label{subsec:versionamento}

No desenvolvimento de aplicações computacionais, é muito comum a ocorrência de
ajustes no projeto, seja para melhorias, adição de alguma funcionalidade ou até
mesmo correções de bugs. Entretanto, em muitos dos casos, qualquer tipo de
alteração é arriscada, pois quando modificamos um ponto do sistema que já
funciona, há chances das modificações afetarem esse ponto, e então, temos um
resultado inesperado, como por exemplo, uma funcionalidade que funcionava
corretamente e, de repente, para de funcionar.\\

Para evitar esse tipo de problema, utilizamos ferramentas de versionamento, que
permitem a realização de um backup de uma instância do projeto, ou seja, podemos
realizar diversas alterações sem nos preocupar se o ajuste será problemático ou
não para o sistema, pois se acontecer algo inesperado, temos a possibilidade de
retornar à instância que funcionava. Atualmente existem diversas ferramentas
que proporcionam esse sistema de versionamento, entrentanto, para esse projeto,
utilizamos a ferramenta Git~\ref{subsec:git} que é muito utilizada na comunidade
de desenvolvedores.

\section{Tecnologia empregada}
\label{sec:tecnologia_empregada}

Está seção especifica todas as tecnologias que foram utilizadas para o
desenvolvimento da aplicação, incluíndo APIs, bibliotecas e frameworks.

\subsection{JDK - Java Development Kit}
\label{subsec:jdk}

O desenvolvimento de aplicações usando a linguagem Java requer o uso do
conhecido \emph{JDK - Java Development Kit}~\cite{jdk}, o qual pode ser obtido
gratuitamente a partir do link disponibilizado na bibliografia. Ele engloba,
entre outras coisas, uma implementação da linguagem Java, um compilador, um
ambiente de interpretação conhecido como máquina virtual Java etc.

\subsection{JPA - Java Persistence API}
\label{subsec:jpa_java_persistence_api}

JPA (Java Persistence API)~\cite{jpa} é uma especificação Java EE, que determina
todas as implementações necessárias, para
que seja possível realizar o
conceito de ORM~\ref{subsec:orm_object_relational_mapping} em Java. Em outras
palavras, para que uma ferramenta ou biblioteca que oferece
o conceito de ORM na linguagem funcione como o esperado, precisa implementar a 
especificação JPA.

\subsection{Hibernate}
\label{subsec:hibernate}

O hibernate é uma das implementações da
JPA~\ref{subsec:jpa_java_persistence_api} para o desenvolvimento de aplicações
utilizando o conceito de ORM~\ref{subsec:orm_object_relational_mapping}. Dentre
as diversas implementações existentes no mercado, o hibernate é a que mais se
destaca pela quantidade de desenvolvedores que o utilizam, ou seja, uma
biblioteca mais estável, com maior suporte e atualizações para novas
funcionalidades com mais frequência.
	
\subsection{Maven}
\label{subsec:maven}

O Maven~\cite{maven} é uma biblioteca capaz de gerenciar projetos Java, com a
finalidade de fazer o \textbf{build} (construção) do projeto resolvendo os
problemas de: \textbf{gerenciamento de dependência}, \textbf{deploy},
\textbf{modularização de projeto}, \textbf{testes} e \textbf{controle de versão do
projeto}. O Maven permite o build do projeto utilizando o \emph{Project Object
Model} (POM).

\subsubsection{POM - Project Object Model}
\label{subsubsec:pom_project_object_model}

O POM é um arquivo XML que permite a configuração de toda estrutura de um
projeto Maven. A partir do pom.xml, temos a capacidade de configurar qualquer
tipo de detalhe do projeto, como por exemplo, qual será o nome, pacote, versão
do Java que será compilado e executado, quais dependências entre outras
possíveis configurações.

\subsubsection{Gerenciamento de dependência}
\label{subsubsec:gerenciamento_de_dependencia}

Durante o desenvolvimento da aplicação, utilizamos outras APIs
para resolver determinados problemas, como por exemplo, o
Spring Framework~\ref{subsec:spring_framework},
Hibernate~\ref{subsec:hibernate}, Jackson~\ref{subsec:jackson} entre outros.
Essas APIs são arquivos .jar que precisam ser baixados e adicionados dentro do projeto, porém, quando fazemos isso
manualmente, nem sempre é uma tarefa simples e tende a apresentar problemas,
como por exemplo o Hibernate que, além de precisar das bibliotecas próprias,
ele necessita da API da JPA~\ref{subsec:jpa_java_persistence_api}. O Maven
resolve todos esses problemas simplesmente adicionando a dependência por meio da tag \lstinline{<denpendency>} onde é
possível visualizar o exemplo da adição da biblioteca do Hibernate a partir
do Código~\ref{lst:dependencia_maven}:

\begin {lstlisting}[caption={Adicionando o hibernate para a o projeto usando o
pom.xml}, label = {lst:dependencia_maven}]
<properties>
	//outras propriedades
	<hibernate.version>4.3.11.Final</hibernate.version>
</properties>

<dependencies>
	//outras dependências
	<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
	</dependency>
<dependencies>

\end{lstlisting}

Nesse exemplo, o maven baixa todas as bibliotecas do Hibernate e suas
dependências, ou seja, a API da JPA e qualquer outra biblioteca
necessária para o seu funcionamento. Dessa forma, delegamos todo o trabalho de
adição, remoção, ou melhor, de gerenciamento de todas as bibliotecas e APIs do
projeto para o Maven.

\subsubsection{distribuição da aplicação - Deploy}
\label{subsubsec:distribuicao_da_aplicacao_deploy}

Todas as vezes que terminamos uma funcionalidade ou até mesmo finalizamos a
aplicação, precisamos distribuí-la para uso, ou seja, publicá-la
ou, tecnicamente falando, fazer o \textit{deploy}. Em muito dos casos, fazer o
deploy da aplicação nem sempre é uma tarefa trivial, pois é necessário se preoculpar com
ambientes diferentes, por exemplo, em ambiente de desenvolvimento, nós
podemos utilizar um banco de dados de teste ou então uma versão qualquer
do JDK. Porém em um ambiente, como por exemplo, de produção, precisamos evitar o
máximo possível de \textit{bugs}, ou seja, tomar alguns cuidados com qual tipo
de configuração a nossa aplicação está utilizando, pois elas são diferentes, ou
seja, se utilizarmos uma configuração que não seja compatível com o ambiente de
produção, consequentemente teremos um erro.
\\

Cuidar manualmente desse tipo de rotina, permite um risco maior de falhas
causando problemas que poderiam ser evitados, como por exemplo, utilizar um usuário 
e senha de banco de dados que não existe no servidor externo, e é justamente por
esses motivos que utilizamos os \emph{profiles} do Maven que são capazes de
criar diferentes perfis para cada tipo de ambiente por meio da tag <profile> 
segue um exemplo de uma configuração para ambiente de desenvolvimento e para
ambiente de produção a partir do Código~\ref{lst:profile_maven}:

\begin{lstlisting}[caption={Criando profiles para ambiente de desenvolvimento e
ambiente de produção no pom.xml}, label = {lst:profile_maven}]
<profiles>

		<profile>
			<id>Development</id>
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
			<properties>
				/*podemos adicionar todas as 
				propriedades para ambiente de desenvolvimento*/
			</properties>
		</profile>

		<profile>
			<id>openshift</id>
			<activation>
				<activeByDefault>false</activeByDefault>
			</activation>
			<properties>
				/* podemos adicionar todas as 
				propriedades para o ambiente de
				produção, nesse caso o openshift */
			</properties>
			<build>

				<finalName>gostoudaaula</finalName>
				<plugins>
					<plugin>
						<artifactId>maven-war-plugin</artifactId>
						<version>2.1.1</version>
						<configuration>
							<outputDirectory>webapps</outputDirectory>
							<warName>ROOT</warName>
						</configuration>
					</plugin>
				</plugins>
			</build>
		</profile>
	</profiles>
\end{lstlisting}

Além de configurar diferentes perfis da aplicação, o Maven também executa uma
rotina que verifica se todo o projeto está funcionando da maneira correta,
por exemplo, verifica se todas as bibliotecas e APIs que foram descritas no
pom.xml estão funcionando corretamente, faz todos os testes que foram realizados
no projeto para garantir se todos funcionaram e também gera os arquivos de
deploy, ou seja, arquivos .jar para aplicações Java e arquivos .war para aplicações
Java Web.

\subsubsection{Modularização de projeto}
\label{subsubsec:modularizacao_de_projeto}

Durante o desenvolvimento da aplicação, utilizamos a arquitetura de módulos, em
outras palavras, o projeto foi divido em módulos. Cada módulo representa um
projeto distinto que tem a apenas uma única finalidade, por exemplo, para
representar todas as classes principais, ou seja, as classes modelos referentes
à regra de negócio, criamos o módulo \textbf{core}, para o acesso de banco de
dados criamos o módulo \textbf{db} e assim por diante. \\

Cada módulo possui o mesmo nome, porém, para diferenciar um do outro, adicionamos os prefixos que os
identifica, por exemplo, o nome da aplicação é gostoudaaula, para o projeto
core, nomeamos como \textit{gostoudaaula-core} e para o banco de dados
\textit{gostoudaaula-db}.

\subsection{Testes - JUnit}
\label{subsec:testes_JUnit}

Como visto no capítulo ~\ref{subsec:tdd_test_driven_development}, para
implementarmos os testes em Java utilizando o conceito de TDD, utilizamos a
biblioteca do JUnit~\cite{junit} que fornece anotações específicas para criarmos
os cenários de teste e testá-los. Os cenários de teste são métodos com uma assinatura que descreve de uma forma bem
explícita o que está sendo testado, por exemplo, um cenário de teste que
verifica se a funcionalidade de cadastrar um aluno está funcionando:

\begin{lstlisting}[caption={Exemplo de um caso de teste utilizando o JUnit}]
	@Test
	public void deveCadastrarUmAluno(){
		//implementação que precisa ser testada
	}
	
\end{lstlisting}

Observe que esse método possui a anotação
\lstinline{@Test}. Essa anotação indica que esse método é testável, ou seja, no
momento em que rodar o JUnit, ele fará parte da pilha de testes. Porém, para
verificar o resultado de alguma funcionalidade, precisamos fazer uso dos métodos
da classe \lstinline{Assert} do próprio JUnit que nos fornece alguns métodos
como o \lstinline{assertTrue} que recebe um método com retorno \emph{booleano},
e se caso o retorno for verdadeiro passará, caso o contrário, falhará. Podemos
ver claramente um exemplo a partir do Código~\ref{lst:asserts_junit}:

\begin{lstlisting}[caption={Exemplo não real de como utilizar o JUnit}, label =
{lst:asserts_junit}] 
import org.junit.Assert;
import org.junit.Test;

public class AlunoTest {

	@Test
	public void deveCadastrarUmAluno() {
		//código para realizar o teste
		Assert.assertTrue(cadastrarAluno());
	}
	
	public boolean cadastrarAluno(){
		//implementação qualquer
		return true;
	}
	
}
\end{lstlisting}

Observe que foi utilizado um método em que sempre retornará \lstinline{true}, ou
seja, o teste sempre passará, justamente para visualizar o resultado exibido na
Figura~\ref{fig:teste_com_sucesso} onde o teste passa.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resultado_sucesso_junit.png}
  \caption{Resultado de um teste que passou utilizando o eclipse}
  \label{fig:teste_com_sucesso}.
\end{figure}

Caso o teste falhasse, o JUnit exibiria uma informação um pouco diferente, além,
de mudar a cor da barra de testes, mostraria o ponto que falhou. Podemos
simular um erro proposital simplesmente alterando o código para que devolva
\lstinline{false}, conforme o Código~\ref{lst:metodo_retornando_falso}:

\begin{lstlisting}[caption={Alteração do resultado de \lstinline{true} para
\lstinline{false}}, label = {lst:metodo_retornando_falso}]
	//restante do código
	
	public boolean cadastrarAluno(){
		//implementação qualquer
		return false;
	}
	
}
\end{lstlisting}

Observe que, diferentemente da Figura~\ref{fig:teste_com_sucesso}, a
Figura~\ref{fig:teste_com_falha} demonstra a resposta que o Junit exibe quando
acontece alguma falha no teste.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resultado_falho_junit.png}
  \caption{Resultado de um teste que falhou utilizando o eclipse}
  \label{fig:teste_com_falha}.
\end{figure}

Perceba que além de mudar a cor para vermelho, ao clicarmos no teste
\emph{deveCadastrarUmAluno}, aparece uma informação precisa onde o testou
falhou. Além disso, vemos que é mostrado o nome da classe que foi testada, o
tempo que o teste levou e a quantidade de testes que foram executados.

\subsection{Servlet API}
\label{subsec:servlet_api}

Servlet (servidorzinho) é uma API fonercida pelo Java que permite
configurarmos uma aplicação como um servidor utilizando a linguagem Java. Essas
aplicações permitem uma comunicação entre cliente e aplicação utilizando o
protocolo HTTP. A partir das Servlets podemos criar aplicações com o conceito de
cliente e servidor~\ref{subsec:cliente_e_servidor}. A API de Servlet, pode ser
adquirida, gratuitamente, no site do próprio Java~\cite{servlet}, atualmente na
versão 3.0.

\subsection{Spring framework}
\label{subsec:spring_framework}

O Spring framework é um conjunto de módulos (projetos)~\cite{spring} em que
tem a finalidade de resolver diversos problemas que são comuns em uma aplicação web, na aplicação foi
utilizado para resolver as questões de controle de transações e injenção de
dependência.

\subsection{Spring Data}
\label{subsec:spring_data}

O Spring Data~\cite{springdata} faz parte de um dos módulos do Spring
framework~\ref{subsec:spring_framework}. O objetivo desse módulo é justamente
facilitar a maneira como persistimos os dados em um banco de dados utilizando o
Spring.

\subsection{Injecão de dependência}
\label{subsec:injecao_de_dependencia}

Durante o desenvolvimento da aplicação, foi utilizada uma grande quantidade de
bibliotecas e APIs. Em Java, ou em qualquer tipo de aplicação orientada a
objetos, sempre que queremos utilizar uma classe, precisamos fazer uma
instância. Entretanto, em alguns casos, principalmente bibliotecas e APIs
externas, é bem comum que, além de fazer uma instância da classe fornecida, aja
a necessidade de realizar certas configurações para que funcione de acordo com a
nossa necessidade. Como por exemplo o Hibernate, que exige que configuremos
todo o ambiente da infraestrutura do banco de dados, como por exemplo,
endereço de acesso, usuário e senha.\\

Tendo em vista esse cenário, é fácil perceber que criar todos esses objetos
manualmente pode ser arriscado, pois podemos esquecer de alguma configuração e
então o nosso sistema pode quebrar. Uma alternativa muito utilizada atualmente,
é justamente a injeção de dependência que consiste no conceito de inversão de
controle~\ref{subsec:inversao_de_controle}, e então, permite que o desenvolvedor
peça ao Spring framework uma instância de um objeto desejado a partir da
anotação \lstinline{@Inject} onde é possível ver o exemplo a partir do
Código~\ref{lst:injecao_de_dependencia}:

\begin{lstlisting}[caption = {Injetando a classe Aluno}, label =
{lst:injecao_de_dependencia}]
@Inject
private Aluno aluno;
\end{lstlisting}

\subsection{Inversão de controle}
\label{subsec:inversao_de_controle}

Embora o objetivo da injeção de dependência~\ref{subsec:injecao_de_dependencia}
seja permitir que o desenvolvedor peça para o Spring uma instância de um objeto
desejado, por padrão, o Spring não sabe como instânciar os objetos! Em outras
palavras, inserir a annotation @Inject não é o suficiente. Portanto, para todo
tipo de objeto que for injetado, é necessário realizar uma configuração que
ensine o Spring a instânciar tal objeto.\\

A partir do momento em que o Spring sabe instânciar um objeto, e então, pedimos
para ele injetá-lo, significa que toda a responsabilidade desde a criação da
instância será transferida para o framework, ou seja, o próprio Spring se torna
responsável. Esse conceito também é conhecido por \textbf{inversão de
controle}, ou, tecnicamente, \textit{Inversion of Control} (IoC).\\

\subsection{Beans do Spring}
\label{subsec:beans_do_spring}

Para que o conceito de inversão de
controle~\ref{subsec:inversao_de_controle} seja possível dentro do Spring,
é necessário configurar a classe que será injetada. Essa configuração consiste
no processo de transformar a classe desejada (classe que deseja injetar) em um
\emph{Bean} do Spring.\\

Os Beans do Spring são todas as classes gerenciadas por ele, ou seja, todas as
classes que o Spring sabe instânciar.
Para transformarmos uma interface ou classe em um bean, basta adicionar uma
tag \lstinline{<bean>} no arquivo XML de configuração do spring, conforme
Código~\ref{lst:bean_spring_exemplo}:

\begin{lstlisting}[caption = {Exemplo de criação do Bean para o EntityManager
do Hibernate}, label = {lst:bean_spring_exemplo}] <beans
xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">
    
	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		
	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	//para adicionar mais beans, adicione mais tags <bean> e ensine como a classe
	precisa ser instanciada

</beans>
\end{lstlisting}

A partir do momento que transformamos uma classe ou interface num Bean do
Spring, temos a disponibilidade de utilizar todo o conceito de injeção de
dependência~\ref{subsec:injecao_de_dependencia}.

\subsection{Controle de transações}
\label{subsec:controle_de_transacoes}

Para conectar a aplicação com o banco de dados, foi utilizada a especificação
JPA (Java Persistence API) que estabalece uma comunição com o banco de dados
criando transações. Porém, todas as vezes que estamos utilizando uma transação
precisamos saber o momento em que ela precisa ser iniciada e o momento em ela
precisa aplicar as ações de commit/rollback e, por fim, fechá-las.\\


Perceba que essas ações podem ser um pouco repitivas como também perigosas para
a nossa aplicação, como por exemplo, interagir com o banco por meio de uma transação e não
realizar o commit, ou então, simplesmente não fechar a conexão. Devido a esses
detalhes, fazemos o uso da injeção de
dependência~\ref{subsec:injecao_de_dependencia} do Spring justamente para que
ele se responsabilize por todo ciclo de vida da transação, isto é, desde sua
abertura, ações e por fim, o seu fechamento. Dessa forma, evitamos de nos
preocupar com quaisquer detalhes que envolvam transações com o banco de dados,
mantendo um sistema mais estável e seguro, pois o próprio framework seguirá
todas as rotinas sem falhas.

\subsection{Flyway DB}
\label{subsec:flyway}

Devido a necessidade de manter a
migration~\ref{subsec:migration_de_banco_de_dados} do banco de dados de uma
forma mais organizada e com menos intervensão humana, nesse projeto, utilizamos
o flyway~\cite{flyway} que é uma ferramenta simples e poderosa, capaz de
realizar a migration de uma maneira bem simplicada.

\subsection{Jackson}
\label{subsec:jackson}

Em uma comunicação entre aplicação utilizando Web
Services~\ref{subsec:web_services}, é muito comum convertemos classes para um
formato em que qualquer aplicação, independemente da implementação (linguagem de
programação), entenda, como por exemplo, XML e JSON. Porém, uma conversão manual
de uma classe passar o formato desejado, nem sempre é um trabalho fácil e por isso não é recomendável esse tipo de prática. Para
facilitarmos essa tarefa, utilizamos a biblioteca do jackson que, com poucas
configurações, consegue realizar essas conversões de forma automática.

\subsection{HikariCP}
\label{subsec:hikari_cp}

O HikariCP é uma biblioteca para melhorar o desempenho das conexões realizadas
entre a aplicação e o banco de dados, por meio de implementações modificadas de
pool de conexões justamente para minimizar o máximo possível de sobrecarga
(\textit{overload}). Isso permite que, em um ambiente de produção, a aplicação 
tenha um desempenho melhor. Nesse projeto não será detalhado informações sobre
connection pool ou o HikariCP, para mais informações, verifique a página web do
próprio HikariCP~\cite{hikaricp} que está disponibilizada na bibliografia.

\subsection{Openshift}
\label{subsec:openshift}

O openshift é uma plataforma como um serviço, também
conhecido como PaaS (Platform-as-a-Service), da Red Hat que permite a criação de 
aplicações em uma infraestrutura na nuvem. Para mais imformações da plataforma consulte o web site~\cite{openshift}.

\subsection{Eclipse IDE for Java EE}
\label{subsec:eclipse_ide_for_java_ee}

Integrated Development Environment (ambiente de desenvolvimento integrado) são
ferramentas que auxiliam o desenvolvedor durante o desenvolvimento de uma
aplicação. O propósito das IDEs é justamente minimizar o tempo de
desenvolvimento de um projeto, como por exemplo, auto preenchimento de código,
busca de recursos, compilação instantânia, sugestão para melhores
implementações, realização de testes entre outras características comuns entre
as principais IDEs do mercado. O Eclipse é uma IDE ~\cite{eclipsejavaee} gratuita e pode ser
adquirida no link disponibilizado na bibliografia. Existem diversas versões para
diversos fins, porém, para essa aplicação, foi utilizada a versão for Java EE
que é justamente predefinida para o desenvolvimento de aplicações Java Web.

\subsection{Android Studio}
\label{subsec:android_studio}

Assim como o Eclipse IDE~\ref{subsec:eclipse_ide_for_java_ee}, o Android Studio
é uma IDE, porém a sua finalidade é justamente facilitar o desenvolvimento de
aplicações para Android. Com diversas características, funcionalidades e
recursos para facilitar o desenvolvimento de uma App. Da mesma forma que o
Eclipse IDE, o Android Studio~\cite{androidstudio} é gratuito e pode ser
adquirido no link disponibilizado na bibliografia.

\subsection{Git}
\label{subsec:git}

Git é um SCM (Software Configuration Management), ou seja, além de ser um
software capaz de manter o conceito de ferramentas de
versionamento~\ref{subsec:versionamento}, também permite o desenvolvimento de um
projeto em time, como por exemplo, a distribuição de versões entre todos os
desenvolvedores seguindo conceitos empregados por esse tipo de software.

\subsection{Gradle}
\label{subsec:gradle}

O Gradle~\cite{gradle} é uma biblioteca capaz de gerenciar projetos Java, com a
finalidade de fazer o \textbf{build} (construção) do projeto. Podemos associar o
Gradle com o Maven~\ref{subsec:maven} justamente porque ambas as ferramentas
utilizam os mesmos conceitos, entretanto, com implementações e features
diferentes. Para esse projeto, o motivo de utilizar o Gradle, é justamente pelo
fato dos projetos Android criados pelo Android
Studio~\ref{subsec:android_studio}, serem nativamente gerenciados pelo Gradle. Portanto, para todo projeto desenvolvido em cima do
Android Studio será utilizada essa ferramenta.
