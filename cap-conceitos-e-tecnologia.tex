%% ------------------------------------------------------------------------- %%
\chapter{Conceitos e Tecnologia}
\label{cap:conceitos_e_tecnologia}

Neste capítulo abordamos os principais conceitos envolvidos durante o
desenvolvimento do projeto proposto. Além disso, um conjunto amplo de
tecnologias utilizadas atualmente no mercado foi empregado, o qual também é
descrito.

%% ------------------------------------------------------------------------- %%
\section{Conceitos}
\label{sec:conceitos}

Esta seção é dedicada a descrições detalhadas independentes de implementação
ou tecnologia sobre os principais conceitos envolvidos durante a elaboração
do projeto. 

\subsection{Modelagem de Dados Conceitual}
\label{subsec:modelagem_de_dados_conceitual}

O desenvolvimento de um sistema computacional que utiliza armazenamento de dados
em meio persistente pode ocorrer de diversas formas. Uma possível abordagem, 
muito utilizada no mercado atualmente, consiste na elaboração de uma descrição 
sobre os dados com os quais a aplicação irá trabalhar. Essa descrição pode 
ser textual ou gráfica e ela é elaborada de forma independente de qualquer 
tecnologia. Em geral, ela é conhecida como modelo conceitual. A modelagem 
conceitual realizada neste trabalho é descrita no
capítulo~\ref{subsec:jpa_java_persistence_api}.

\subsection{Modelagem de Dados Relacional}
\label{subsec:modelagem_de_dados_relacional}
Uma vez obtida a descrição conceitual dos dados, a sua implementação pode ser
realizada de diferentes formas. Entre as mais utilizadas no mercado atual está 
a modelagem relacional, que consiste no uso de tabelas para o armazemamento dos
dados, além de diferentes restrições, como chaves primárias e estrangeiras.


Criar subseções para os seguintes itens: 
linguagem SQL e álgebra relacional (é só para descrever o que é, sem mostrar
código)
orientação a objetos
Mapeamento Objeto Relacional
Web Services
Dispositivos Móveis e aplicações

\subsection{SQL e álgebra relacional}
\label{subsec:sql_e_algebra_relacional}

Structured Query Language (linguagem de consulta estruturada) é uma linguagem de
pesquisa padrão para banco de dados relacionais, onde permite a comunicação com
um banco de dados para a realização de consultas simples ou com álgebra
relacional. A álgebra relacional é uma teoria de como podemos manipular as
consultas realizadas utilizando o SQL, como por exemplo, mencionar quais são os
atributos e filtros que necessários com o intuito de devolver o resultado
esperado.
\begin{equation}
	\sigma_{id = 1} (Empregado)
\end{equation}
\subsection{Orientação a objetos}
\label{subsec:orientacao_a_objetos}

O paradigma de POO (programação orientada a objetos) é um modelo para o
desenvolvimento de software ao qual utilizamos unidades chamadas de
objetos. Esse paradigma nos permite modelar um sistema
computacional por meio desses objetos que representam todas as entidades
contidas no sistema que, por sua vez, refletem as abstrações de um objeto da
vida real para a aplicação, como por exemplo, na modelagem para essa aplicação,
foi necessário modelar a entidade aula que representa uma aula da vida real que
compõe um aluno, um professor e qualquer outra informação que seja necessária
para essa entidade.

Os objetos dessas entidades são identificadas como classes que possuem estados
(atributos) e comportamentos (métodos) que definem suas responsabilidades e
razão de existir. 

\begin {lstlisting}[caption={Exemplo de como podemos criar 3 classes e adicionar seus
atributos}]
class Aula {
	
	Aluno aluno;
	Professor professor;
	
	//atributos e métodos
	
}

class Professor {
	
	List<Aula> aulas;
	
	//atributos e métodos
	
}

class Aluno {
	
	List<Aula> aulas;
	
	//atributos e métodos
	
}
\end{lstlisting}

Além disso, na POO, temos grandes benefícios devido aos
recursos de encapsulamento, herança, polimorfismo que permitem o
desenvolvimento de um sistema mais coerente, seguro e manutenível. 

\subsubsection{Encapsulamento}
\label{subsubsec:encapsulamento}

O encapsulamento é um recurso que tem o objeto de esconder todos os passos que
são realizados para apenas uma chamada de método. Podemos verificar um pequeno
exemplo de encapsulamento durante uma chamada 

\begin{lstlisting}[caption={Exemplo de utilização do encapsulamento para
calcular um bonus}]
class CalculadorDeBonus {

	double calcularBonus(double salario){
		if(salario < 1000){
			return salario * 0.15;
		} else {
			return salario * 0.10;
		}
	}
	
	//atributos e métodos

}

class Funcionario {

	double salario;
	double bonus;
	
	double getBonus(){
		bonus = new CalculadorDeBonus().calcularBonus(this.salario);
		return bonus;
	}

}

\end{lstlisting}

Observe que a classe \lstinline{Funcionario} possui os atributos
\lstinline{salario} e \lstinline{bonus} e o método \lstinline{getBonus()}.
Quando alguém, que não seja a classe \lstinline{Funcionario} chamar o método
\lstinline{getBonus()}, saberá como esse bonus é calculado? A resposta é não!
Pois todos os passos, procedimentos ou qualquer que seja a rotina realizada para
calcular o bonus está escondida! Além disso, observe que a classe
\lstinline{Funcionario} faz uma chamada ao método \lstinline{calcularBonus(double salario)} que também possui seus procedimentos, ou seja, passos que nem mesmo a
classe \lstinline{Funcionario} sabe, ou seja, outro exemplo de encapsulamento! É
fácil compreender que o encapsulamento é justamente esconder o código para que
todos que o chamem, não precisem saber como funciona por de trás dos panos,
porém, quais são os benefícios que temos ao utilizá-lá? 


\begin{itemize}
\item Segurança.
\begin{itemize}
\item Não exibir como tudo é feito por de trás dos panos.
\item Não permitir que alterem qualquer valor que esteja dentro do método.
\end{itemize}
\item Manutenabilidade.
\begin{itemize}
\item Se um dia os procedimentos, passos ou qualquer parte do código
encapsulada precisarem ser alterados(as), basta apenas alterar dentro de um
único método.
\end{itemize}
\item Reutilização de código.
\begin{itemize}
\item Permite a possibilidade e reutilizar o mesmo código, exigindo apenas uma
chama à função que encapsulou todo algoritmo.
\end{itemize}
\end{itemize}

\subsubsection{Herança}
\label{subsubsec:heranca}

A herança é um dos principais recursos da orientação a objetos, pois, por meio
dela, podemos criar classes filhas de uma classe. Quando dizemos que uma classe
é uma filha de outra, significa que a classe filha herda todos os atributos e
métodos da classe mãe, ou seja, ela possuirá o mesmo comportamento que sua
classe mãe, porém, ela também terá os seus próprios comportamentos. Por exemplo,
na aplicação, fizemos uma abstração de um usuário qualquer no sistema, o
resultado obtido dessa abstração foi a classe \lstinline{Usuario}:

\begin{lstlisting}[caption={Exemplo de uma classe que representa um usuário no
sistema}]
public class Usuario {
	
	long id;
	String senha;
	String nome;
	String sobrenome;
	
	//métodos e atributos
	
}
\end{lstlisting}

Essa classe, como podemos ver, pode representar qualquer usuário dentro da
aplicação, porém, nessa aplicação, existem 2 tipos de usuários, que são os
alunos e professores, que consequentemente, possuem comportamentos diferentes no
sistema, mas, além de suas diferenças, eles possuem semelhanças que são os
atributos id, senha, nome, sobrenome ou qualquer outro tipo de comportamento ou
estado que é esperado de qualquer usuário. 

Temos diversas formas de resolver essa distinção dentro de um sistema
computacional, porém, uma das soluções possíveis e sofisticada dentro da orientação a objetos, é fazer com que a classe
\lstinline{Professor} e \lstinline{Aluno} herdem da classe \lstinline{Usuario},
pois, dessa forma, faremos com que ambas possuam os mesmo comportamentos de um
usuário qualquer, mas, que cada uma tenha o seu próprio comportamento dentro da
aplicação. Para fazer com que uma classe herde de outra, basta utilizar a
instrução \lstinline{extends}:

\begin{lstlisting}[caption={Exemplo de como criamos classes filhas utilizando a
herança do Java}]
public class Usuario {
	
	long id;
	String senha;
	String nome;
	String sobrenome;
	
	//métodos e atributos
	
}

public class Aluno extends {

	//atributos, métodos
	 
}

public class Professor extends {

	//atributos, métodos
	 
}
\end{lstlisting}

A partir do momento em que as classes \lstinline{Aluno} e \lstinline{Professor}
estendem da classe \lstinline{Usuario}, significa que, além de representarem
elas mesmos dentro da aplicação, elas também são um usuário, ou seja, a partir
desse momento, qualquer comportamento e estado que estiver na classe
\lstinline{Usuario}, serão herdados por essas classes.

\subsubsection{Polimorfismo} 
\label{subsubsec:polimorfismo}

Um dos principais pontos da herança em orientação a objetos, é a questão em que,
uma classe filha reutilize um comportamento herdado, porém, que precise de
alguma moficação peculiar daquela classe, por exemplo, imaginemos que a classe
\lstinline{Usuario} contenha o método \lstinline{cadastrarSenha(String senha)},
esse método, dentro da classe \lstinline{Usuario} possui um processo de
criptografia padrão, e para a classe professor, precisa utilizar um padrão
diferente ao qual um usuário qualquer use, pra permitimos que isso seja possível
utilizando a mesma assinatura de método, reescrevemos o método da classe
\lstinline{Usuario} dentro da classe \lstinline{Professor} e adicionamos o
comportamento específico e esperado daquele método para a classe
\lstinline{Professor}:

\begin{lstlisting}[caption={Exemplo de polimorfismo da classe filha Professor e
classe mãe Usuario}]
class Usuario {

	public cadastrarSenha(String senha){
		//passos e rotinas da classe Usuario
	}

}

class Professor extends {

	@Override
	public cadastrarSenha(String senha){
		//passos e rotinas da classe Professor
	}

}
\end{lstlisting}

Note que foi utilizada uma \emph{annotation} do Java que indica que o método
pertence a uma classe mãe, porém ele está sendo sobrescrito, ou seja, ele terá
um comportamento diferente do padrão.

\subsection{ORM - Object Relational Mapping}
\label{subsec:orm_object_relational_mapping}

Mapeamento Objeto Relacional (ORM - Object Relational Mapping) é uma técnica que
permite a persistência em um banco de dados utilizando o paradigma orientado a
objeto. Isso significa que as entidades de um banco de dados podem ser
representadas por meio de classes e seus atributos. A utilização dessa
técnica para o desenvolvimento de um sistema computacional deve-se à facilidade
que um programador tem ao desenvolver um sistema que exija uma comunicação
constante com o banco de dados, pois ele não precisa obter um alto conhecimento
de SQL ou banco de dados para conseguir realizar consultas, persistências,
alterações dados ou qualquer tipo de ação que o banco de dados e a aplicação
terão. A aplicação desse conceito no Java, é descrita com mais na seção
~\ref{subsec:jpa_java_persistence_api}.

\subsection{Web Services}
\label{subsec:web_services}

Os serviços na web é uma solução muito utilizada no mercado para permitir que
diversas aplicações, independentemente da plataforma em que foram desenvolvidas,
consigam se comunicar com o sistema via um protocolo de rede em comum, como
por exemplo o HTTP. Essa comunicação é permitida devido ao tipo de
mensagem/documento que é processado para enviar e receber os dados, como por
exemplo, arquivos XML ou documentos JSON. Além de permitir a comunicação entre
diversas aplicações, o web services tem o intuito de disponibilizar serviços que
são acessíveis por meio de endereços públicos da aplicação. 

\subsection{Dispositivos Móveis e Aplicações}
\label{subsec:dispositivos_moveis_e_aplicacoes}

Segundo o relatório do International Data Corporation (IDC) publicado
em maio de 2012, o Android possui 59\% do mercado de smartphones e soma
a quantia de 89,9 milhões de aparelhos distribuídos apenas no primeiro tri-
mestre deste ano (2012), em todo o mundo. Em segundo lugar, aparece o iOS
que é o sistema operacional do Apple iPhone. O gráfico 1.1 demonstra a par-
ticipação no mercado dos principais sistemas operacionais e a quantidade de
aparelhos distribuídos.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{grafico_android_2012.png}
  \caption{Participação no mercado. Fonte: IDC ~\cite{jbmonteiro:12}}
  \label{fig:grafico_android_2012}.
\end{figure}

O IDC também prevê que, em 2016, o Android ainda possuirá a maior
fatia do mercado, com 52,9\%. A disputa pelo segundo lugar será acirrada
entre iOS e Windows Phone 7. A ~\ref{fig:grafico_android_2012} ilustra a
previsão realizada pelo IDC.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{grafico_android_2016.png}
  \caption{Previsão do mercado para 2016. Fonte: IDC
  ~\cite{jbmonteiro:12}}
  \label{fig:grafico_android_2016}
\end{figure}

Já no mercado de tablets, o iPad detém o trono com 68\% , enquanto o
Google aposta em seu primeiro tablet, o Nexus 7 ao preço US\$199,00, para
ga- nhar terreno tentando repetir o sucesso do Amazon Kindle Fire, que também
utiliza Android.

\subsection{MVC - Model View Controller}
\label{subsed:mvc_model_view_controller}

A arquitetura MVC consiste em dividir a aplicação em camadas:
\begin{itemize}
  \item \textit{\textbf{Model:}} Representa toda a regra de negócio da
  aplicação, ou seja, todas as classes, configuração, acessos À base de dados ou qualquer recurso
  que esteja do lado do servidor e que o usuário final não tenha acesso.
  \item \textit{\textbf{View:}} Todo conteúdo que representa a parte visual da
  aplicação, ou seja, qualquer interface com o usuário.
  \item \textit{\textbf{Controller:}} É o responsável em receber todas as
  requisições do usuário (\emph{View}) direcionar à aplicação o que foi solicitado
  (\emph{Model}) e por fim, enviar uma resposta ao usuário.
\end{itemize}

A partir dessa arquitetura, podemos desenvolver uma aplicação de uma
forma mais organizada e segura, pois além de dividirmos todo o conteúdo de acesso ao
usuário (páginas em HTML ou qualquer interface direta ao usuário) e a regra de
negócio (classes, configurações, acesso aos dados ou qualquer parte interna do
sistema) deixamos transparente como tudo funciona internamente, ou seja, o
usuário enxerga apenas o que ele precisa saber sem ter noção alguma de como é o
sistema internamente.

\subsection{TDD - Test Driven Development}
\label{subsec:tdd_test_driven_development}

O desenvolvimento das funcionalidades da aplicação, foi baseado na prática do
TDD (Test Driven Development) que tem a finalidade de fazer com que o
desenvolvedor crie primeiro o cenário de teste e então desenvolva a
funcionalidade, por exemplo, suponhamos que precisamos criar uma funcionalidade
que precise cadastrar um aluno no banco de dados, quando utilizamos o TDD
criamos um método responsável por testar essa funcionalidade que a aplicação
precisa.\\

O principal objetivo da utilização do TDD é garantir que a aplicação contenha
menos bugs, pois ao invés de implementar a aplicação toda para depois testá-la,
implementamos ``pedaços'' da aplicação e então testamos esses pedaços, ou seja, 
implementamos o código necessário para realizar o teste que precisamos, por
exemplo, se precisamos cadastrar um aluno no sistema ou verificar se o login
funciona como o esperado, implementamos cada uma dessas funcionalidades da forma
mais simples possível apenas para serem testadas. A diferença entre testar
pedaços da aplicação ao invés da aplicação num todo, é que permitimos que a nossa aplicação seja mais coerente, 
segura e flexível, pois implementaremos métodos pequenos e com apenas uma
responsabilidade, dessa forma garantimos que a funcionalidade esteja funcionando
e então, permitimos que ela seja reutilizada em qualquer parte do código sem
preocupações de falhas. Além disso, se um dia precisarmos realizar alguma
alteração de uma funcionalidade, alteraremos apenas em um ponto do sistema. \\

Como podemos ver, a prática do TDD, além de nos ajudar a garantir um sistema
mais confiável, tende a criar diversos cenários dentro da aplicação, aumentando
muito mais o desenvolvimento do sistema. A princípio parece uma prática que mais atrapalha do que ajuda o desenvolvimento, porém,
quando estamos desenvolvendo, é muito comum que ocorra muitas mudanças no código
e nem sempre conseguimos prever o quão impactante foi a alteração, ou seja, se
ainda funciona ou se não quebrou o nosso sistema. Para verificar
esse detalhe, inicialmente, pensamos em \textbf{testar manualmente tudo
novamente} para verificar se ocorreu algum problema. Além de ser trabalhoso,
provavelmente, esqueceremos de testar todas as funcionalidades do sistema, ou
seja, a chance de não garantir que tudo esteja funcionando como o esperado, é
muito grande. Quando utilizamos o TDD, todos os cenários de testes que criamos
são testados automaticamente, como uma \emph{pilha de processos}, dessa forma,
evitamos perder tempo em verificar manualmente cada cenário e, se algum teste falhar, a
nossa própria aplicação mostratará o que e onde falhou com muito mais precisão.
\\

Para utizarmos o conceito de TDD em Java, podemos utilizar a API do JUnit que é
descrita com mais detalhes no capítulo ~\ref{subsec:testes_JUnit}.

\subsection{cliente e servidor}
\label{subsec:cliente_e_servidor}

Em aplicações Web, como por exemplo websites, é muito comum encontrarmos a
arquitetura de aplicação conhecida como \emph{cliente e servidor}, que é
justamente uma aplicação autônoma (servidor) que recebe diversas requisições de
diversos usuários (cliente) e responde de acordo com o que cada cliente
requisitou, como por exemplo, se um cliente solicita uma página de cadastro, o
servidor entende recebe essa requisição, executa os passos necessários e
responde com a página solicitada.

\subsection{Servidor de aplicação}
\label{subsec:servidor_de_aplicacao}

Em aplicações Web, é muito comum utilizarmos um servidor que será responsável em
manter a aplicação ativa. Esses servidores são conhecidos como servidores de
aplicação e, uma de suas principais responsabilidades, é manter as aplicações
disponíveis para receber requisições e respondê-las
~\ref{subsec:cliente_e_servidor}.

\section{Tecnologia empregada}
\label{sec:tecnologia_empregada}

Está seção especifica todas as tecnologias que foram utilizadas para o
desenvolvimento da aplicação, incluíndo APIs, bibliotecas e frameworks.

\subsection{JDK - Java Development Kit}
\label{subsec:jdk}

O desenvolvimento de aplicações usando a linguagem Java requer o uso do
conhecido \emph{JDK - Java Development Kit}~\cite{jdk}, o qual pode ser obtido
gratuitamente a partir do link disponibilizado na bibliografia. Ele engloba,
entre outras coisas, uma implementação da linguagem Java, um compilador, um
ambiente de interpretação conhecido como máquina virtual Java etc.

\subsection{JPA - Java Persistence API}
\label{subsec:jpa_java_persistence_api}

JPA (Java Persistence API) é uma especificação Java EE que determina tudo que
uma implementação de ORM (Object-Relational Mapping) para Java, precisa
implementar para que seja uma biblioteca funcional de persistência de dados
utilizando ORM. 

\subsection{Hibernate}
\label{subsec:hibernate}

O hibernate é uma das implementações da
JPA~\ref{subsec:jpa_java_persistence_api} para o desenvolvimento de aplicações
utilizando o conceito de ORM~\ref{subsec:orm_object_relational_mapping}. Dentre
as diversas implementações existentes no mercado, o hibernate é a que mais se
destaca pela quantidade de desenvolvedores que o utilizam, ou seja, uma
biblioteca mais estável, com maior suporte e atualizações para novas
funcionalidades com mais frequência.
	
\subsection{Maven}
\label{subsec:maven}

O maven é uma biblioteca capaz de gerenciar projetos Java, com a finalidade de
fazer o \emph{build} (construção) do projeto resolvendo os problemas de: gerenciamento de
dependência, deploy, modularização de projeto, testes e controle de versão do
projeto. O Maven permite o build do projeto utilizando o \emph{Project Object
Model} (POM). O POM é um arquivo XML que descreve todas as informaçõees que o
projeto Maven possui, como por exemplo, lista de dependências, configurações de
plugins, profiles entre outras iformações que o projeto possa ter. A partir do
pom.xml, podemos configurar todas as propriedades para indicar como o Maven se
comportará.

\subsection{Gerenciamento de dependência}
\label{subsec:gerenciamento_de_dependencia}

Durante o desenvolvimento da aplicação, utilizamos outras APIs
para resolver determinados problemas, como por exemplo, o Spring, Hibernate,
Jackson entre outros. Todas as essas APIs são arquivos .jar que precisam ser
baixadas e adicionadas ao projeto, porém, quando fazemos isso manualmente, nem
sempre é uma terá simples e tende apresentar problemas, como por exemplo o
Hibernate que, além de precisar das bibliotecas próprias, precisa da API da JPA.
O Maven resolve todos esses problemas simplesmente adicionando a dependência por
meio da tag <denpendency>: 

\begin {lstlisting}[caption={Adicionando o hibernate para a o projeto usando o
pom.xml}]
<properties>
	//outras propriedades
	<hibernate.version>4.3.11.Final</hibernate.version>
</properties>

<dependencies>
	//outras dependências
	<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
	</dependency>
<dependencies>

\end{lstlisting}

\subsection{distribuição da aplicação - Deploy}
\label{subsec:distribuicao_da_aplicacao_deploy}

Todas as vezes que terminamos uma funcionalidade ou até mesmo finalizamos a
aplicação, precisamos distribuir essa aplicação para uso, ou seja, publicá-la
ou, tecnicamente falando, fazer o deploy. Em muito dos casos, fazer o deploy da
aplicação nem sempre é uma tarefa trivial, pois é necessário se preoculpar com
ambientes diferentes, por exemplo, em ambiente de desenvolvimento, nós
podemos utilizar um banco de dados de teste, podemos utilizar qualquer versão do
JDK entre outras tarefas que não impactam o cliente, porém em um ambiente de
produção precisamos evitar o máximo possível de bugs, ou seja, tomar cuidado com
qual tipo de configuração a nossa aplicação está utilizando. Cuidar manualmente
desse tipo de rotina permite um risco maior de falhas causando problemas que
poderiam ser evitados, como por exemplo, utilizar um usuário e senha de banco de
dados que não existe no servidor externo, e é justamente por esses motivos que
podemos utilizar os \emph{profiles} do Maven que são capazes de criar diferentes
perfis para cada tipo de ambiente por meio da tag <profile> segue um exemplo de
uma configuração para ambiente de desenvolvimento e para ambiente de produção:

\begin{lstlisting}[caption={Criando profiles para ambiente de desenvolvimento e
ambiente de produção no pom.xml}]
<profiles>

		<profile>
			<id>Development</id>
			<activation>
				<activeByDefault>true</activeByDefault>
			</activation>
			<properties>
				/*podemos adicionar todas as 
				propriedades para ambiente de desenvolvimento*/
			</properties>
		</profile>

		<profile>
			<id>openshift</id>
			<activation>
				<activeByDefault>false</activeByDefault>
			</activation>
			<properties>
				/* podemos adicionar todas as 
				propriedades para o ambiente de
				produção, nesse caso o openshift */
			</properties>
			<build>

				<finalName>gostoudaaula</finalName>
				<plugins>
					<plugin>
						<artifactId>maven-war-plugin</artifactId>
						<version>2.1.1</version>
						<configuration>
							<outputDirectory>webapps</outputDirectory>
							<warName>ROOT</warName>
						</configuration>
					</plugin>
				</plugins>
			</build>
		</profile>
	</profiles>
\end{lstlisting}


Além de configurar diferentes perfis da aplicação, o Maven também executa uma
rotina em que verifica se todo o projeto está funcionando da maneira correta,
por exemplo, verifica se todas as bibliotecas e APIs que foram descritas no
pom.xml estão funcionando corretamente, faz todos os testes que foram realizados
no projeto para garantir se todos funcioram e também gera os arquivos de deploy,
ou seja, arquivos .jar para aplicações Java e arquivos .war para aplicações
Java Web.

\subsection{Modularização de projeto}
\label{subsec:modularizacao_de_projeto}

O desenvolvimento da aplicação foi baseado em módulos, isso significa que
existe mais de um projeto que resolve um problema em específico, por exemplo,
existe o projeto gostoudaaula-core que possui todas as classes modelos da
aplicação, o projeto gostoudaaula-db que possui todas as classes que cuidam da
lógica de banco de dados e o projeto gostoudaaula-web que é a aplicação web em
si. Podemos fazer uso desse tipo de arquitetura por meio dos módulos do Maven. 
Para criarmos módulos no Maven precisamos primeiro criar um projeto do Maven que
chamando de parent, esse projeto será o projeto principal da aplicação, ou seja,
iremos incluir todos os demais projetos dentro dele. Na aplicação foi criado o
projeto gostoudaaula-parent. A figure 2.1 demonstra a estrutura do projeto
parent:

\begin{figure}
\captionof{figure}{Estrutura do projeto parent}
\end{figure}

Para adicionar módulos para esse projeto, precisaremos criar novos projetos
Maven dentro desse projeto e então precisamos incluir o nome desses na tag <module>:

\begin{lstlisting}[caption={Exemplo para associar os projetos como módulos no
pom.xml}]
	<modules>
		<module>
			gostoudaaula-core
		</module>
		<module>
			gostoudaaula-web
		</module>
		<module>
			gostoudaaula-db
		</module>
	</modules>
\end{lstlisting}

Nesse exemplo estamos indicando que os projetos citados serão os módulos do
projeto parent, porém ainda precisamos especificar aos módulos quem será o
parent, então adicionamos a tag <parent> no pom.xml:

\begin{lstlisting}[caption={Exemplo de como informar qual é o parent do modulo no
pom.xml}]
	<parent>
		<groupId>br.com.gostoudaaula</groupId>
		<artifactId>gostoudaaula-parent</artifactId>
		<version>//versão</version>
	</parent>
\end{lstlisting}

\subsection{Testes - JUnit}
\label{subsec:testes_JUnit}

Como visto no capítulo ~\ref{subsec:tdd_test_driven_development}, para
implementarmos os testes em Java utilizando o conceito de TDD, utilizamos a
biblioteca do JUnit que fornece anotações específicas para criarmos os cenários de teste e testá-los. Os
cenários de teste são métodos com uma assinatura que descreve de uma forma bem
explícita o que está sendo testado, por exemplo, um cenário de teste que
verifica se a funcionalidade de cadastrar um aluno está funcionando:

\begin{lstlisting}[caption={Exemplo de um caso de teste utilizando o JUnit}]
	@Test
	public void deveCadastrarUmAluno(){
		//implementação que precisa ser testada
	}
	
\end{lstlisting}

Observe que esse método possui a anotação
\lstinline{@Test}. Essa anotação indica que esse método é testável, ou seja, no
momento em que rodar o JUnit, ele fará parte da pilha de testes. Porém, para
verificar o resultado de alguma funcionalidade, precisamos fazer uso dos métodos
da classe \lstinline{Assert} do próprio JUnit que nos fornece alguns métodos
como o \lstinline{assertTrue} que recebe um método com retorno \emph{booleano},
e se caso o retorno for verdadeiro passará, caso o contrário, falhará. Podemos
ver claramente nos seguintes exemplos:

\begin{lstlisting}[caption={Exemplo não real de como utilizar o JUnit}]
import org.junit.Assert;
import org.junit.Test;

public class AlunoTest {

	@Test
	public void deveCadastrarUmAluno() {
		//código para realizar o teste
		Assert.assertTrue(cadastrarAluno());
	}
	
	public boolean cadastrarAluno(){
		//implementação qualquer
		return true;
	}
	
}
\end{lstlisting}

Observe que foi utilizado um método em que sempre retornará \lstinline{true}, ou
seja, o teste sempre passará, justamente para exibir a figura

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resultado_sucesso_junit.png}
  \caption{Resultado de um teste que passou utilizando o eclipse}
  \label{fig:teste_com_sucesso}.
\end{figure}

Caso o teste falhasse, o JUnit exibiria uma informação um pouco diferente, além,
de mudar a cor da barra de testes, mostraria o ponto que falhou. Podemos
verificar um dos casos simplesmente alterando o método para devolver
\lstinline{false}:

\begin{lstlisting}[caption={Alteração do resultado de \lstinline{true} para
\lstinline{false}}]
	//restante do código
	
	public boolean cadastrarAluno(){
		//implementação qualquer
		return false;
	}
	
}
\end{lstlisting}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{resultado_falho_junit.png}
  \caption{Resultado de um teste que falhou utilizando o eclipse}
  \label{fig:teste_com_sucesso}.
\end{figure}

Perceba que além de mudar a cor para vermelho, ao clicarmos no teste
\emph{deveCadastrarUmAluno}, aparece uma informação precisa onde o testou
falhou. Além disso, vemos que é mostrado o nome da classe que foi testada, o
tempo que o teste levou e a quantidade de testes que foram executados.

\subsection{Servlet API}
\label{subsec:servlet_api}

Servlet (servidorzinho) é uma API fonercida pelo Java que permite
configurarmos uma aplicação como um servidor utilizando a linguagem Java. Essas
aplicações permitem uma comunicação entre cliente e aplicação utilizando o
protocolo HTTP. A partir das Servlets podemos criar aplicações com o conceito de
cliente e servidor~\ref{subsec:cliente_e_servidor}. A API de Servlet, pode ser
adquirida, gratuitamente, no site do próprio Java~\cite{Servlet}, atualmente na
versão 3.0.

\subsection{Spring framework}
\label{subsec:spring_framework}

O Spring framework é um conjunto de módulos (projetos)~\cite{spring} em que
tem a finalidade de resolver diversos problemas que são comuns em uma aplicação web, na aplicação foi
utilizado para resolver as questões de controle de transações e injenção de
dependência.

\subsection{Injecão de dependência}
\label{subsec:injecao_de_dependencia}

Durante o desenvolvimento da aplicação, foi utilizado uma grande quantidade de
bibliotecas e APIs, porém, em Java, ou em qualquer tipo de aplicação orientada a
objetos, sempre que queremos utilizar uma classe, precisamos fazer uma
instância, no caso de APIs, além de fazer uma instância, na maioria das vezes,
precisamos realizar certas configurações para que funcione de acordo com a nossa
necessidade. O Spring framework fornece para nós um recurso conhecido como
injeção de dependência, que consiste em atribuir uma instância a um
objeto automaticamente. Quando queremos que um objeto seja injetado, utilizamos
a anotação @Inject, que indica que o objeto será injetado:

\begin{lstlisting}
	@Inject
	private Aluno aluno;
\end{lstlisting}

\subsection{Inversão de controle}
\label{subsec:inversao_de_controle}

A injeção de dependência atribuirá as instâncias necessárias para os objetos que
estão anotados com @Inject, porém, para que o Spring consiga injetar esses
objetos, precisamos ensinar o Spring a criar essas instâncias. Quando ensinamos
o Spring a criar instâncias, podemos configurar como a instância será criada e
então o Spring passa a gerenciar todas as classes que estão anotadas com
@Inject, fazendo com que o programador não precise mais se preocupar em
instânciar esses objetos, essa abordagem de fazer com que o framework instancie
os objetos é chamada de Inversão de Controle (IoC).

\subsection{Beans do Spring}
\label{subsec:beans_do_spring}

Quando ensinamos o Spring a instanciar uma classe, essa classe se tornará um
\emph{Bean} do Spring. Os Beans do Spring são todas as classes gerenciadas pelo
ele, ou seja, serão todas as classes que o Spring saberá criar as instâncias.
Para transformarmos uma interface ou classe em um bean, basta adicionar uma
tag <bean> no arquivo XML de configuração do spring:

\begin{lstlisting}
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">
    
	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		
	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	//para adicionar mais beans, adicione mais tags <bean> e ensine como a classe
	precisa ser instanciada

</beans>
\end{lstlisting}

\subsection{Controle de transações}
\label{subsec:controle_de_transacoes}

Para conectar a aplicação com o banco de dados, foi utilizada a especificação
JPA (Java Persistence API) que estabalece uma comunição com o banco de dados
criando transações. Porém, todas as vezes que estamos utilizando uma transação
precisamos saber o momento em que ela precisa ser iniciada e o momento em ela
precisa aplicar as ações de commit/rollback e por fechá-las. Perceba que essa
ações podem ser um pouco repitivas como também perigosas para a nossa aplicação,
como por exemplo, interagir com o banco por meio de uma transação e não
realizar o commit, ou então, simplesmente não fechar a conexão. Devido a esses
detalhes, utilizamos o Spring para fazer a injeção de dependência das classes
que são responsáveis em lidar com as transações, ou seja, o Spring gerencia
todas as transações da aplicação, garantindo que todas essas rotinas sejam
feitas corretamente sem o desenvolvedor precisar se preocupar.

\subsection{Jackson}
\label{subsec:jackson}

Em uma comunicação entre aplicação utilizando Web
Services~\ref{subsec:web_services}, é muito comum convertemos classes para um
formato em que qualquer aplicação, independemente da implementação, ou seja,
linguagem de programação, entenda, como por exemplo, XML e JSON. Porém, uma
conversão manual de uma classe passar o formato desejado, nem sempre é um
trabalho fácil e por isso não é recomendável esse tipo de prática. Para
facilitarmos essa tarefa, utilizamos a biblioteca do jackson que, com poucas
configurações, consegue realizar essas conversões de forma automática.

\subsection{Openshift}
\label{subsec:openshift}

O openshift é uma plataforma como um serviço, também
conhecido como PaaS (Platform-as-a-Service), da Red Hat que permite o os
desenvolvedores a criar aplicações em uma infraestrutura na nuvem. Para mais
imformações da plataforma consulte o web site~\cite{openshift}.

\subsection{Eclipse IDE for Java EE}
\label{subsec:eclipse_ide_for_java_ee}

Integrated Development Environment (ambiente de desenvolvimento integrado) são
ferramentas que auxiliam o desenvolvedor durante o desenvolvimento de uma
aplicação. O propósito das IDEs é justamente minimizar o tempo de
desenvolvimento de um projeto, como por exemplo, auto preenchimento de código,
busca de recursos, compilação instantânia, sugestão para melhores
implementações, realização de testes entre outras características comuns entre
as principais IDEs do mercado. O Eclipse é uma IDE ~\cite{eclipsejavaee} gratuita e pode ser
adquirida no link disponibilizado na bibliografia. Existem diversas versões para
diversos fins, porém, para essa aplicação, foi utilizada a versão for Java EE
que é justamente predefinida para o desenvolvimento de aplicações Java Web.

\subsection{Android Studio}
\label{subsec:android_studio}

Assim como o Eclipse IDE~\ref{subsec:eclipse_ide_for_java_ee}, o Android Studio
é uma IDE, porém a sua finalidade é justamente facilitar o desenvolvimento de
aplicações para Android. Com diversas características, funcionalidades e
recursos para facilitar o desenvolvimento de uma app. Da mesma forma que o
Eclipse IDE, o Android Studio~\cite{androidstudio} é gratuito e pode ser
adquirido no link disponibilizado na bibliografia.

  