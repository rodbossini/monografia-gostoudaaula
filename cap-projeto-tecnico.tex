\chapter{Projeto Técnico}
\label{cap:projet/home/alex-felipe/git/monografia-gostoudaaula/cap-conceitos-e-tecnologia.texo_tecnico}

\section{Modelagem de banco de dados}
\label{sec:modelagem_de_banco_de_dados}

A aplicação \emph{Gostou da Aula?} teve seu desenvolvimento iniciado pela
modelagem conceitual dos dados. Após análise detalhada, obtivemos um Diagrama
Entidade Relacionamento, o qual é exibido pela figura ~\ref{fig:der}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{DER.jpg}
  \caption{Diagrama Entidade Relacionamento - DER}
  \label{fig:der}.
\end{figure}

Cada entitidade e relacionamento possui determinadas peculiaridades que são
descritas a seguir:

\begin{itemize}
  \item \textbf{Usuário}: Refere a uma representação de um usuário qualquer no
  sistema, essa é uma entidade abstrata, ou seja, exige uma especilização entre
  a entidade \textbf{Professor} e \textbf{Aluno} que são os 2 tipos de usuários
  existentes na aplicação.
  \item \textbf{Professor}: Representa um professor dentro da aplicação.
  \item \textbf{Aluno}: Representa um aluno dentro da aplicação.
  \item \textbf{Aula}: Representa uma aula dentro da aplicação, é constituída
  por \textbf{Aluno(os)}, um \textbf{Professor} e um \textbf{Periodo}.
  \item \textbf{Periodo}: Representa um período letivo dentro da instituição, é
  constituído por uma \textbf{Disciplina} e uma \textbf{Turma}.
  \item \textbf{Turma}: Representa uma turma da instituição.
  \item \textbf{Disciplina}: Representa uma disciplina da instituição.
  \item \textbf{Avaliacao}: Representa uma avaliação dentro da aplicação, é
  constituída por uma \textbf{Aula}, um \textbf{Projeto} e
  \textbf{Resposta(as)}.
  \item \textbf{Projeto}: Representa um projeto dentro da aplicação constituído
  por \textbf{Questoes} das avaliações.
  \item \textbf{Questoes}: Representa todas as questões de um determinado
  \textbf{Projeto}.
  \textbf{Respostas}: Representa todas as respostas de \textbf{Questoes} e
  \textbf{Avaliacao}.
\end{itemize} 

\section{Criação do projeto via Maven}
\label{sec:cricao_do_projeto_via_maven}

Para a criação do projeto, foi utilizada a biblioteca do
Maven~\ref{subsec:maven}. Há diversos modos para a criação de um projeto
utilizando a biblioteca do Maven, como por exemplo o terminal, porém, para essa
aplicação foi utilizado o Eclipse IDE~\ref{subsec:eclipse_ide_for_java_ee}, pois
ele já contém algumas facilidades, como por exemplo, escolher os menus de
criação em um modo gráfico e simplesmente digitar as informações necessárias sem
ao menos ficar escrevendo vários comandos. \ 

Para criar um projeto Maven no eclipse, basta clicar no menu ``File > New >
Project\ldots'', então aparecerá a janela conforme a figura
~\ref{fig:projeto_filtro_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project1.png}
  \caption{filtrando projetos com ``Maven'' no Eclipse IDE}
  \label{fig:projeto_filtro_maven}.
\end{figure}

Então escolhemos a opção ``Maven Project'' que exibe a janela conforme a
figura~\ref{fig:projeto_criacao_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project2.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_criacao_maven}.
\end{figure}

Lembre-se de deixar marcada a opção ``Create a simple project (skip archetype
selection)'' justamente para avançar o passo em que seleciona o archetype do
Maven~\cite{archetype} que é descrito com mais detalhes no link disponibilizado
na bibliografia.Então clicamos em ``Next'' e aparece a janela de acordo com 
a figura~\ref{fig:projeto_informacoes_maven} :

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project3.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_informacoes_maven}.
\end{figure}

Observe que agora é necessário adicionar algumas informações do Maven, que é
justamente o \textit{\textbf{Group Id}}, \textit{\textbf{Artifact Id}},
\textit{\textbf{Version}} e \textit{\textbf{Package}}. Cada uma das informações
possuem uma grande importante para aplicação. As descrições de cada um desses
itens estão disponíveis com detalhes no link disponibilizado na
bibliografia~\cite{namingmaven}.

Após a criação, o projeto Maven padrão criado pelo Eclipse contém a estrutura de
acordo com a figura~\ref{fig:projeto_maven_padrao}.

\begin{figure}[H]
  \centering 
  \includegraphics[width=0.7\textwidth]{project_explorer_for_maven.png}
  \caption{Estrutura do projeto Maven padrão criado pelo Eclipse}
  \label{fig:projeto_maven_padrao}.
\end{figure}

Basicamente, o diretório \textbf{src} é o local onde colocaremos todos os
arquivos fonte do projeto, como por exemplo, código, properties ou
qualquer arquivo de recurso da aplicação. Podemos observar que a estrutura
desse diretório contém mais dois subdiretórios: \textbf{main} e
\textbf{test}. Cada um desses subdiretório possuem objetivos e escopos
diferentes, que são descritos a seguir:

\begin{itemize}
  \item \textbf{main}: Todos os arquivos principais da aplicação, isto é,
  qualquer implementação destinada à aplicação, serão adicionados dentro desse
  diretório.
  \item \textbf{test}: Todos os arquivos de teste da aplicação, em outras
  palavras, qualquer tipo de código para realizar os testes da aplicação.
\end{itemize}

Além desses dois diretórios, para cada um deles, existem os subdiretórios
\textbf{java} e \textbf{resources} com os seguintes objetos:

\begin{itemize}
  \item \textbf{java}: Todos os arquivos de extensão .java, em outras palavras,
  todo código relacionado à classes Java, serão adicionados dentro desse
  diretório.
  \item \textbf{resources}: Todos os recursos da aplicação, como por exemplo,
  configurações em XML, .properties ou qualquer tipo de recurso para a aplicação
  que seja diferente de um arquivo de extensão .java, será adicionado nesse
  diretório.
\end{itemize}

\subsection{Utilizando modulos com Maven}
\label{subsec:utilizando_modulos_com_maven}

A arquitetura para o desenvolvimento da aplicação, foi planejado com a ideia da
criação de módulos~\ref{subsubsec:modularizacao_de_projeto}. Para essa aplicação
foram criados 3 módulos:

\begin{itemize}
  \item \textbf{core}: Adicionar as classes de regra de negócio representadas
  no diagrama de classes~\ref{sec:diagrama_de_classes}.
  \item \textbf{db}: Todas as classes para conexão com o banco de dados.
  \item \textbf{web}: Todas as classes e configuração para aplicação Web e
  configuração de conexão ao banco de dados.
\end{itemize}

Tendo conhecimento que cada projeto é independente um do outro, um dos pontos
importantes é saber como eles se comunicam entre eles. No Maven, utilizamos o
conceito Parent e childs descritos~\ref{subsec:parent_e_childs_com_maven}.

\subsection{Parent e childs com Maven}
\label{subsec:parent_e_childs_com_maven}

O conceito de parent e childs do Maven é justamente criar um projeto pai
(parent) e seus filhos (childs). O projeto pai, é um projeto genérico que não
possui código fonto ou qualquer arquivo de configuração. Ele é utilizado como
\textit{container} de seus filhos que de fato, são os módulos da aplicação.
Paara essa aplicação utilizamos também o mesmo nome de projeto para o parent,
porém com o sufixo \textbf{parent}.\\

Para configurar um projeto parent, simplesmente adicionamos os módulos no
pom.xml conforme o código~\ref{lst:adicao_de_modulos}:

\begin{lstlisting}[caption = {Adicionando módulos no projeto parent}, label
={lst:adicao_de_modulos}] 
	<modules>
		<module>
			gostoudaaula-core
		</module>
		<module>
			gostoudaaula-web
		</module>
		<module>gostoudaaula-db</module>
	</modules>
\end{lstlisting}

Além de informar ao parent quais são os seus módulos, todos os filhos precisam
também informar quem é o pai deles dentro do pom.xml adicionando o código:

\begin{lstlisting}[caption = {Adicionando o parent dentro de um módulo},
label={lst:adicao_de_parent}]
	<parent>
		<groupId>br.com.gostoudaaula</groupId>
		<artifactId>gostoudaaula-parent</artifactId>
		<version>0.1.9-SNAPSHOT</version>
	</parent>
\end{lstlisting}

A partir do momento em que um projeto Maven declara quem é o seu pai, todos os
recursos e dependências do pai são herdados a ele, ou seja, suas dependências e
arquivos de configurações. Porém, mesmo os modulos sendo filhos do mesmo pai,
não significa que cada um tem acesso direto ao outro, para resolver isso basta
adicionar os módulos necessários em cada projeto como uma
dependência~\ref{subsubsec:gerenciamento_de_dependencia}.




\section{Dependências de todos os módulos}
\label{sec:dependencias_de_todos_os_modulos}

Uma das grandes vantagens em utilizar o Maven é justamente pelo gerenciamento de
dependência~\ref{subsubsec:gerenciamento_de_dependencia}. Visto na
subseção~\ref{subsec:utilizando_modulos_com_maven}, a aplicação é baseada em
módulos que representam um projeto independemente, logo, cada um desses projetos possuem
suas respectivas dependências, e serão disponibilizadas a seguir:

\begin{itemize}
  \item \textbf{parent}~\ref{lst:dependencias_parent}:
  \begin{lstlisting}[caption = {Dependências do parent}, label =
  {lst:dependencias_parent}] 
  	<dependencies>
		<!-- Teste -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest-core</artifactId>
			<version>1.3</version>
			<scope>test</scope>
		</dependency>

		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
			<optional>true</optional>
		</dependency>

		<!-- data -->
		<dependency>
			<groupId>joda-time</groupId>
			<artifactId>joda-time</artifactId>
			<version>2.9</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{core}~\ref{lst:dependencias_core}: 
  \begin{lstlisting}[caption = {Dependências do core}, label =
  {lst:dependencias_core}]
  	<dependencies>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>


		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>

		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt</artifactId>
			<version>1.9.2</version>
		</dependency>

	</dependencies>  
  \end{lstlisting}
  \item \textbf{db}~\ref{lst:dependencias_db}:
  \begin{lstlisting}[caption = {Dependências do db}, label =
  {lst:dependencias_db}]
  	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>

		<!-- Spring data -->
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-jpa</artifactId>
			<version>1.9.2.RELEASE</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{web}~\ref{lst:dependencias_web}:
  \begin{lstlisting}[caption = {Dependências do web}, label = {lst:dependencias_web}] 
  	<dependencies>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-db</artifactId>
			<version>${project.version}</version>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<version>9.2-1003-jdbc4</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.25</version>
		</dependency>

		<!-- Básicas -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>xml-apis</groupId>
			<artifactId>xml-apis</artifactId>
			<version>1.4.01</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>


		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
		</dependency>

		<!-- Spring MVC -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${spring.version}</version>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Gerais -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.4</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-email</artifactId>
			<version>1.4</version>
		</dependency>
		<dependency>
			<groupId>commons-codec</groupId>
			<artifactId>commons-codec</artifactId>
			<version>1.10</version>
		</dependency>
		<dependency>
			<groupId>net.sargue</groupId>
			<artifactId>java-time-jsptags</artifactId>
			<version>1.0.0</version>
		</dependency>

		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>2.6.3</version>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
		</dependency>
	</dependencies>  
  \end{lstlisting}
\end{itemize}

\section{Diagramas de UML utilizados} 
\label{sec:diagramas_de_uml_utilizados}

No planejamento para a implementação da aplicação, utilizamos a
UML~\ref{subsec:uml} para representar de uma forma mais clara o que tinha que
ser implementado dentro da aplicação. Dentre os diversos diagramas existentes da
UML, foram utilizados apenas os diagramas de
\textbf{classes}~\ref{subsec:diagrama_de_classes_utilizado},\textbf{caso de
uso}~\ref{subsec:diagrama_de_caso_de_uso_utilizado} e de \textbf{sequência}.

\subsection{Diagrama de classes utilizado}
\label{subsec:diagrama_de_classes_utilizado}

Em projetos de aplicações orientadas a objetos, antes mesmo de começar a
implementar as classes, é muito comum utilizarmos o diagrama de
classes~\ref{subsubsec:diagrama_de_classes} para uma visibilidade estática de
como devemos implementar as classes.
Para essa aplicação utilizamos o diagrama de classe conforme a figura~\ref{fig:diagrama_de_classes}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_classes.png}
  \caption{Diagrama de classes}
  \label{fig:diagrama_de_classes}.
\end{figure}

\subsection{Diagrama de caso de uso utilizado}
\label{subsec:diagrama_de_caso_de_uso_utilizado}

Além do diagrama de classe~\ref{subsec:diagrama_de_classes_utilizado}, é de
grande importância utilizarmos o diagrama de caso de
uso~\ref{subsubsec:diagrama_de_caso_de_uso} para obtermos uma visão macro sobre
as principais funcionalidades. Para essa aplicação, utilizamos o diagrama
conforme a figura~\ref{fig:diagrama_de_caso_de_uso}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_caso_de_uso.png}
  \caption{Diagrama de caso de uso}
  \label{fig:diagrama_de_caso_de_uso}.
\end{figure}

\subsection{Diagrama de sequência utilizado}
\label{subsec:diagrama_de_sequencia_utilizado}

Dentre as funcionalidades apresentadas no diagrama de caso de
uso~\ref{fig:diagrama_de_caso_de_uso}, a principal funcionalidade é a
\textbf{avaliar aula} que possui diversos passos para que seja realizada, porém,
para especificar tal funcionalidade utilizamos o diagrama de
sequência~\ref{subsubsec:diagrama_de_sequencia} conforme a
figura~\ref{fig:diagrama_de_sequencia}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_sequencia.png}
  \caption{Diagrama de sequência para a funcionalidade \textbf{avaliar aula}}
  \label{fig:diagrama_de_sequencia}.
\end{figure}

\section{Configurando projeto web}
\label{sec:configurando_projeto_web}

\subsection{Configurando o Spring MVC}
\label{subsec:configura_o_spring_mvc}

O projeto web foi baseado na estrutura do Spring
MVC~\ref{subsec:spring_framework}, porém, a configuração inicial é realizada
dentro do arquivo ``src/main/webapp/views/web.xml'' que refere-se ao arquivo de
configuração da estrutura de um projeto Java Web. Dentro desse arquivo temos a
capacidade de configurar diversos comportamentos da aplicação, como por exemplo,
quais Servlets~\ref{subsec:servlet_api} serão utilizadas, qual endereço HTTP
será atendido dentre outros recursos. Para esse projeto foi utilizado o seguinte
XML~\ref{lst:web.xml_app_web} de configuração:

\begin{lstlisting}[caption={web.xml completo da aplicação web},
label={lst:web.xml_app_web}]
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0">
	<display-name>gostou da aula?</display-name>

	<servlet>
        <servlet-name>spring mvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <multipart-config>
            <max-file-size>500</max-file-size>
            <max-request-size>1000</max-request-size>
        </multipart-config>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring mvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>
\end{lstlisting}

Essa configuração descreve qual será a Servlet do Spring que será utilizada,
juntamente com a localização dessa Servlet. Além disso, descreve a partir de
qual endereço o Spring atuará, nesse caso, pra todo endereço que fizer parte da
``/'' (qualquer endereço via HTTP) será atendido pelo Spring, por fim, a
configuração de encoding que é justamente a formatação dos caracteres, para esse
projeto foi utilizado o UTF-8.\\

Com o arquivo web.xml configurado, precisamos criar o arquivo de configuração do
próprio Spring, que atuará como o projeto Spring MVC. Como visto no
código~\ref{lst:web.xml_app_web} a localização e nome do arquivo corresponde ao
seguinte valor: \textbf{classpath:spring/spring-mvc.xml}. Isso significa que
esse arquivo será procurado dentro do diretório:
``src/main/resources/spring/'', então criamos o arquivo \textbf{spring-mvc.xml}
com o conteúdo de acordo com o código:

\begin{lstlisting}[caption={spring-mvc.xml completo da aplicação web},
label={lst:spring-mvc.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc
	http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd 
	http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<mvc:annotation-driven />

	<mvc:default-servlet-handler />
	<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	<context:component-scan base-package="br.com.gostoudaaula" />

	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>

	<import resource="spring-jpa-config.xml" />
	<import resource="spring-flyway-config.xml" />
	<import resource="spring-ioc.xml" />
</beans>
\end{lstlisting}

O arquivo spring-mvc.xml concentra todas as configuração relacionadas ao Spring
MVC, como por exemplo o código~\ref{lst:configurando_mapeamento_de_paginas}:

\begin{lstlisting}[caption={configuração para o Spring mapear e acessar as
páginas web com extensões .jsp~\cite{jsp}},
label={lst:configurando_mapeamento_de_paginas}]
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
\end{lstlisting}
 
Além das configurações do Spring MVC, foram adicionadas as configurações de injeção de dependência~\ref{subsec:injecao_de_dependencia} do Spring
Framework, JPA~\ref{subsec:jpa_java_persistence_api} e
Hibernate~\ref{subsec:hibernate} e mensageria. Cada configuração está contida em
arquivos distintos que dentro do mesmo diretório do arquivo spring-mvc.xml. Abaixo serão
listado os arquivos com suas finalidades e sua configuração:

\begin{itemize}
  \item \textbf{spring-jpa-config.xml}: Todas as
  configurações relacionadas à configuração da JPA por meio da implementação do
  hibernate e o HikariCP~\ref{subsec:hikari_cp}. Toda a configuração está
  descrita no código:
  \begin{lstlisting}[caption={spring-jpa-config.xml completo da aplicação web},
  label={lst:spring-jpa-config.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
     http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

	<tx:annotation-driven transaction-manager="jpaTransactionManager" />

	<bean id="hibernateJpaVendorAdapter"
		class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter" />

	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
		depends-on="flyway">

		<property name="persistenceUnitName" value="${jpa.persistenceUnitName}" />
		<property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" />
		<property name="packagesToScan" value="${jpa.packagesToScan}" />

		<property name="jpaPropertyMap">
			<map>
				<entry key="hibernate.dialect" value="${hibernate.dialect}" />
				<entry key="hibernate.enable_lazy_load_no_trans" value="true" />

				<entry key="hibernate.show_sql" value="${hibernate.show_sql}" />
				<entry key="hibernate.format_sql" value="${hibernate.format_sql}" />

				<entry key="hibernate.connection.provider_class" value="${hibernate.connection.provider.class}" />
				<entry key="hibernate.hikari.dataSourceClassName" value="${hikari.datasource.class}" />
				<entry key="hibernate.hikari.dataSource.user" value="${hikari.datasource.user}" />
				<entry key="hibernate.hikari.dataSource.password" value="${hikari.datasource.password}" />
				<entry key="hibernate.hikari.dataSource.url" value="${hikari.datasource.url}" />

				<entry key="hibernate.hikari.maximumPoolSize" value="${hikari.pool.maxSize}" />
				<entry key="hibernate.hikari.connectionTimeout" value="${hikari.pool.timeOut}" />
				<entry key="hibernate.hikari.poolName" value="${hikari.pool.name}" />

				<entry key="hibernate.hikari.dataSource.cachePrepStmts" value="${hikari.ds.cache.prepStmts}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSize"
					value="${hikari.ds.cache.size}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSqlLimit"
					value="${hikari.ds.cache.sqlLimit}" />
				<entry key="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy" />
			</map>
		</property>
	</bean>

	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	<!-- configuração do spring data -->
	<jpa:repositories base-package="br.com.gostoudaaula.db"
		entity-manager-factory-ref="entityManagerFactory"
		transaction-manager-ref="jpaTransactionManager" 
		/>
</beans>
  \end{lstlisting}
   \item \textbf{spring-flyway-config.xml}: Todas as
  configurações relacionadas à integração do flyway~\ref{subsec:flyway} com o
  banco de dados. Toda a configuração está descrita no código:
  \begin{lstlisting}[caption={spring-flyway-config.xml completo da aplicação
  web}, label={lst:spring-flyway-config.xml_completo_da_app}]
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	
		<bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate">
			<property name="schemas" value="${flyway.schemas}" />
			<property name="encoding" value="${flyway.encoding}" />
			<property name="dataSource" ref="dataSource" />
			<property name="initOnMigrate" value="true" />
		</bean>
	
		<bean id="dataSource"
			class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="driverClassName" value="${flyway.datasource.class}" />
			<property name="url" value="${flyway.datasource.url}" />
			<property name="username" value="${flyway.datasource.username}" />
			<property name="password" value="${flyway.datasource.password}" />
		</bean>
	
	</beans>
  \end{lstlisting}
   \item \textbf{spring-ioc.xml}: Todas as configurações realacionadas a
   injeção de dependência~\ref{subsec:injecao_de_dependencia} aplicando o
   conceito de inversão de controle~\ref{subsec:inversao_de_controle}.
   Toda a configuração está descrita no código:
     \begin{lstlisting}[caption={spring-ioc.xml completo da aplicação
  web}, label={lst:spring-ioc.xml_completo_da_app}]
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
	    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	    http://www.springframework.org/schema/context
	    http://www.springframework.org/schema/context/spring-context-3.0.xsd
	    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd ">
	
	
		<context:property-placeholder
			file-encoding="UTF-8"
			location="classpath:properties/general.properties, classpath:properties/database.properties,
		 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	
		<context:annotation-config></context:annotation-config>
		<context:component-scan base-package="br.com.gostoudaaula" />
	
		<bean id="ObjectMapper" class="com.fasterxml.jackson.databind.ObjectMapper"
			scope="request">
			<aop:scoped-proxy />
		</bean>
	
		<import resource="spring-flyway-config.xml" />
		<import resource="spring-jpa-config.xml" />
	
	</beans>
     \end{lstlisting}
\end{itemize}

\subsection{Propriedades do projeto}
\label{propriedades_do_projeto}

Em alguns beans do Spring MVC, os valores foram atribuídos por meio expression
language~\cite{el}, como por exemplo o bean do flyway~\ref{lst:bean_flyway}:

\begin{lstlisting}[caption={bean do flyway}, label={lst:bean_flyway}]
<bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate">
	<property name="schemas" value="${flyway.schemas}" />
	<property name="encoding" value="${flyway.encoding}" />
	<property name="dataSource" ref="dataSource" />
	<property name="initOnMigrate" value="true" />
</bean>
	
\end{lstlisting}

Observe que para a \textit{property} schemas, foi atribuído o valor
\textit{\$\{flyway.schemas\}}. Esses valores são extraídos a partir de arquivos
properties~\cite{properties}. Nesse projeto, para que o Spring MVC consiga
encontrar e ler os arquivos properties, e então, extrair seus valores, foi
definido o caminho
\textbf{classpath:properties}
dentro do arquivo
\textbf{spring-mvc.xml}~\ref{lst:spring-mvc.xml_completo_da_app}. Para definir o
caminho basta apenas adicionar a tag \textbf{<context:property-placeholder />}
informando o \textit{enconding} dos arquivos e a locatização de todos os
arquivos que serão lidos. Podemos ver uma demonstração utilizada nesse projeto a
partir do código~\ref{lst:property_placeholder}:


\begin{lstlisting}[caption={property-placeholder do projeto},
label={lst:property_placeholder}]
<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	
\end{lstlisting}

Observe que temos 4 arquivos distintos dentro do projeto. Cada arquivo contém
informações relacionadas a um tipo de configuração, por exemplo:

\begin{itemize}
  \item \textbf{general.properties:} Definições gerais do projeto.
  \item \textbf{database.properties:} Definições do banco de dados.
  \item \textbf{flyway.properties:} Definições do flyway.
  \item \textbf{jpa.properties:} Definições da JPA.
\end{itemize}

Como exemplo veremos o conteúdo do \textbf{general.properties} a partir do
código~\ref{lst:conteudo_do_general.properties}:

\begin{lstlisting}[caption={conteúdo do general.properties},
label={lst:conteudo_do_general.properties}]	
#Configurações gerais
encoding = UTF-8
url = ${url}
\end{lstlisting}

\subsection{Configurando flyway}
\label{subsec:configurando_flyway}

Além das definições realizadas pelo flyway, é necessária a existência de um
arquivo SQL para que ele consiga gerenciar as migrations do banco de dados.
Porém, no flyway, precisamos seguir uma convenção para que ele consiga gerenciar
da forma adequada. Nesse projeto foi utilizado apenas um único arquivo com o
seguinte nome \lstinline{V1__Criacao_tabelas_base.sql}.\\

Note que o arquivo contém \textbf{V1} que indica a versão, nesse caso, é a
versão 1, então é adicionado 2 \textit{underscores} e, em seguida, o nome do
arquivo de uma forma bem verbosa, ou seja, explicando explicítamente o que ele
significa e por fim adicionando a extensão SQL.\\

O conteúdo desses arquivos são instruções SQL, ou seja, toda a instrução contida
nesse arquivo V1 será executada assim que o flyway for executado. Caso seja
necessário algum tipo de modificação no banco de dados, basta criar um novo
arquivo com somando 1 com a versão final, por exemplo, a versão atual é a 1, a
próxima seria V2 e assim sucessivamente.\\

Para esse projeto, todos esses arquivos do flyway precisam ser inseridos no
\textbf{classpath:db/migration}.

\section{Estrutura do projeto web}
\label{sec:estrutura_do_projeto_web}

\subsection{Controllers do Spring}
\label{subsec:controllers_do_spring}

No projeto web, para inicializarmos a aplicação a partir de uma arquitetura
MVC~\ref{subsec:mvc_model_view_controller} começamos pela criação de
controllers. Nesse projeto, adicionamos todas as classes de controller no
pacote: \textbf{br.com.gostoudaaula.controller}.\\

Para criar uma classe que representa um controller, é recomendado a utilização
da seguinte convenção: \textit{NomeDaClasseController}, ou seja, o nome da
classe junto com o prefixo ~\textit{Controller}. Por exemplo, nesse projeto, o
controller que representa a página de vísita, isto é, a página inicial foi
denominado como \lstinline{SiteController}, podemos ver o seu conteúdo a partir
do código~\ref{lst:site_controller}:

\begin{lstlisting}[caption={código da classe SiteController},
label={lst:site_controller}]	
package br.com.gostoudaaula.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import static org.springframework.web.bind.annotation.RequestMethod.GET;

@Controller
@RequestMapping("/")
public class SiteController {

	@RequestMapping(method = GET)
	public String index() {
		return "index";
	}
}
\end{lstlisting}

Observe que esse controller contém duas annotations~\cite{annotations}:

\begin{itemize}
  \item \textbf{@Controller:} Indica que a classe será um controller do Spring
  MVC
  \item \textbf{@RequestMapping:} Indica que a partir da URL ``/'', esse
  controller irá atender.
\end{itemize}

Além disso, o método \lstinline{index} também está anotado com um
\lstinline{@RequestMapping}, porém, diferente da annotation da classe que recebe
uma string como valor, essa contém um atributo \lstinline{method} com o valor
\lstinline{GET}. Isso significa que, se a requisição for para a ``/'' e o método
de requisição do HTTP~\cite{requestmethod} for GET, esse método será atendido.\\

Além disso, observe que esse método retorna uma String com o valor ``index'',
isso significa que o Spring MVC tentará encontrar uma página dentro do projeto
no diretório \textbf{src/main/webapp/WEB-INF/views} com a extensão .jsp conforme
a configuração do arquivo spring-mvc.xml~\ref{lst:spring-mvc.xml_completo_da_app}

\subsection{Services do Spring}
\label{subsec:services_do_spring}

Na arquitetura MVC o controller é o responsável em receber as informações do
cliente, e então, delegar para um especialista, ou seja, uma classe capaz de
realizar a tarefa solicitada. Teoricamente, se ele receber uma requisição para
cadastrar algum objeto, significa que ele precisa passar a diante para uma
classe que faça a persistência de dados, ou então, se a requisição é para apenas
validar dados, enviará para uma classe que faça isso.\\

Mesmo sendo funcional, tal prática dentro de um controller não é recomendável,
justamente pelo controller ser responsável em apenas delegar. Em outras
palavras, controllers não se comunicam diretamente com essas classes
específicas, e sim, delegam tais tarefas para classes conhecidas como services.
Dentro do Spring, os services são basicamente uma camada que fica entre a parte
lógica (persistência de dados, validação, tratamento e geral) e o controller
para resolver qualquer tipo de requição para uma entidade, por exemplo, se é
necessário cadastrar uma turma, ou até mesmo validá-la, enviamos tal
requisição para um service que conterá todas as funcionalidades da entidade
turma.\\

No Spring, para criarmos um service, seguimos a seguinte convenção:
\textit{NomeDaClasseService}, ou seja, o nome da
classe junto com o prefixo ~\textit{Service}. Nesse projeto, todas as services
foram adicionadas no pacote \textbf{br.com.gostoudadaula.service}. Como exemplo,
veremos o service \lstinline{TurmaService} a partir do
código~\ref{lst:turma_service}, que representa um service exclusivo da entidade
turma:

\begin{lstlisting}[caption={código da classe TurmaController},
label={lst:turma_service}]	
package br.com.gostoudaaula.service;

import javax.inject.Inject;

import org.springframework.stereotype.Service;

import br.com.gostoudaaula.db.repository.TurmaRepository;
import br.com.gostoudaaula.model.Turma;

@Service
public class TurmaService {

	private TurmaRepository repository;

	@Inject
	public TurmaService(TurmaRepository repository) {
		this.repository = repository;
	}

	public void salva(Turma turma) {
		repository.save(turma);
	}

	public Turma retorna(Turma turma) {
		return repository.findOne(turma.getId());
	}

}
\end{lstlisting}

Além do nome da classe ter o prefixo \textit{Service}, observe que também
precisamos adicionar a annotation \lstinline{@Service} para indicar ao Spring
que essa classe será gerenciada por ele como um service. 

\section{Estrutura do projeto db}
\label{estrutura_do_projeto_db}

\subsection{Utilizando o Spring Data}
\label{utilizando_o_spring_data}

No projeto db, ao invés de utilizarmos classes com o design pattern DAO (Data
Access Object)~\cite{dao}, a partir do módulo Spring
Data~\ref{subsec:spring_data}, nesse projeto foi utilizado o conceito de
repositories Spring Data~\cite{repositoriesspring}. No Spring,
repositories são representações de classes onde ocorre a persistência de
dados. A princípio existe uma certa similiaridade com classes DAO, entretanto,
no Spring Data, representamos um repository a partir de uma interface que
estende de classes fornecidas pelo Spring Data.\\

A representação mais básica para um repository é a partir da classe
\lstinline{CrudRepository<T,ID extends Serializable>}~\cite{crudrepository} que
já contém métodos de CRUD (Create Read Update and Delete), ou seja, métodos que são bem comuns durante uma implementação de um
DAO. A vantagem em utilizar esse tipo de abordagem é justamente o ganho em
produtividade, pois, dessa forma, evitamos de ficar escrevendo diversas linhas
de código que fazem rotinas em comum, como por exemplo, inserção de dados.\\

Nesse projeto, adicionamos todos os repositories dentro do pacote
\textbf{br.com.gostoudaaula.db.repository}. Podemos ver  um exemplo de
um repository a partir da interface \lstinline{RespostasRepository} a partir do
código~\ref{lst:respostas_repository}:

\begin{lstlisting}[caption={código da interface RespostasRepository},
label={lst:respostas_repository}]
package br.com.gostoudaaula.db.repository;

import java.util.List;
import org.joda.time.LocalDate;
import org.springframework.data.repository.CrudRepository;
import br.com.gostoudaaula.model.Avaliacao;
import br.com.gostoudaaula.model.Respostas;

public interface RespostasRepository extends CrudRepository<Respostas, Long>{

	Respostas findByData(LocalDate localDate);

	public List<Respostas> findByAvaliacao(Avaliacao avaliacao);
}
\end{lstlisting}

Nesse repository, representamos a interface que fará todas as transações com o
banco de dados para a classe modelo \lstinline{Respostas}. Observe que no
momento em que a interface é estendida, passamos dois valores como
generics~\cite{generics}, que significa o tipo da classe que será persistida e o
tipo do seu id. Nesse caso a classe \lstinline{Respostas} é a classe que será
persistida e o \lstinline{Long} é o tipo do id da classe dentro do banco de
dados.\\

Além dos métodos CRUDs que são fornecidos pela classe
\lstinline{CrudRepository<T,ID extends Serializable>}, observe que a classe
\lstinline{RespostasRepository} contém mais duas assinaturas. Essas assinaturas
são alternativas de busca de registros para a classe \lstinline{Respostas}
dentro do banco de dados, por exemplo, a assinatura \lstinline{findByData}
indica que queremos retornar um objeto do tipo \lstinline{Respostas} a partir do
atributo chamado ``data'' dentro da classe \lstinline{Respostas} com o tipo
\lstinline{LocalDate}.\\

\section{Estrutura do projeto core}
\label{estrutura_do_projeto_core}

No projeto core, foram adicionadas todas as classes modelos, DTOs~\cite{dto},
mixins do Jackson~\ref{subsec:jackson} e conversores. 

\subsection{Models}
\label{models}

Todas as classes modelos estão contidas
no pacote \lstinline{br.com.gostoudaaula.model} onde cada classe representa uma
entidade do sistema. Como por exemplo a classe \lstinline{Disciplina} a partir
do código~\ref{lst:model_disciplina}:

\begin{lstlisting}[caption={código da classe Disciplina},
label={lst:model_disciplina}]
package br.com.gostoudaaula.model;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import org.hibernate.validator.constraints.NotEmpty;

@Entity
public class Disciplina implements Serializable {

	private static final long serialVersionUID = 1L;
	private Long id;
	private String descricao;

	public Disciplina() {
	}

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	@NotEmpty
	public String getDescricao() {
		return descricao;
	}

	public void setDescricao(String descricao) {
		this.descricao = descricao;
	}

}
\end{lstlisting}

Observe que essa classe contém anotações da JPA justamente por se tratar de uma
representação de uma disciplina no banco de dados do projeto. 

\subsection{DTO}
\label{dto}

Todas as classes DTO estão contidas no pacote
\lstinline{br.com.gostoudaaula.dto}. A partir dessas classes podemos transferir
dados de formas de uma forma diferente ao qual contemos em classes
models~\ref{models}, justamente para atender a uma necessidade que apenas o
conteúdo contido em uma entidade não seja o suficiente. Nesse projeto, temos
apenas a classe \lstinline{PeriodoDTO} como exemplo, podemos ver o seu conteúdo
a partir do código~\ref{lst:periodo_dto}:

\begin{lstlisting}[caption={código da classe PeriodoDTO},
label={lst:periodo_dto}]
package br.com.gostoudaaula.dto;

import javax.persistence.Convert;

import org.joda.time.LocalDate;
import org.springframework.format.annotation.DateTimeFormat;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

import br.com.gostoudaaula.converter.DateConverter;
import br.com.gostoudaaula.json.LocalDateDeserializer;
import br.com.gostoudaaula.json.LocalDateSerializer;
import br.com.gostoudaaula.model.PeriodoLetivo;

public class PeriodoDTO {

	LocalDate inicio;
	LocalDate fim;
	PeriodoLetivo periodoLetivo;

	public PeriodoDTO() {
	}

	public PeriodoDTO(PeriodoLetivo periodoLetivo, LocalDate inicio, LocalDate fim) {
		this.periodoLetivo = periodoLetivo;
		this.inicio = inicio;
		this.fim = fim;
	}

	@DateTimeFormat(pattern = "dd/MM/yyyy")
	@Convert(converter = DateConverter.class)
	@JsonSerialize(using = LocalDateSerializer.class)
	@JsonDeserialize(using = LocalDateDeserializer.class)
	public LocalDate getInicio() {
		return inicio;
	}

	public void setInicio(LocalDate inicio) {
		this.inicio = inicio;
	}

	@DateTimeFormat(pattern = "dd/MM/yyyy")
	@Convert(converter = DateConverter.class)
	@JsonSerialize(using = LocalDateSerializer.class)
	@JsonDeserialize(using = LocalDateDeserializer.class)
	public LocalDate getFim() {
		return fim;
	}

	public void setFim(LocalDate fim) {
		this.fim = fim;
	}

	public PeriodoLetivo getPeriodoLetivo() {
		return periodoLetivo;
	}

	public void setPeriodoLetivo(PeriodoLetivo periodoLetivo) {
		this.periodoLetivo = periodoLetivo;
	}

}
\end{lstlisting}

Observe que essa classe contém apenas atributos e e anotações para conversão de
de atributos para documentos JSON. Portanto, essas classes são utilizadas apenas
para transferirmos dados.

\subsection{Mixins do Jackson}
\label{minins_do_jackson}

Todos os mixins estão contidos no pacote
\lstinline{br.com.gostoudaaula.json.mixins}. Mixins são classes auxiliares
durante a serialização de um objeto a partir da biblioteca do Jackson. A partir
dos mixins, podemos limitar os atributos que serão serializados em qualquer tipo
de classe, ou seja, caso algum tipo de atributo seja delicado, como por exemplo,
uma senha, ou então, por algum motivo qualquer não seja preferível que um
atributo de uma determinada classe seja serializado, podemos utilizar os mixins
para resolver esse problema.\\

Nesse projeto, além da situação em que não era interessante um determinado
atributo durante a serialização, também utilizamos os mixins justamente para os
casos em que temos relacionamentos bidirecionais na utilização da JPA. Como por
exemplo as classes \lstinline{Projeto}~\ref{lst:model_projeto} e
\lstinline{Questoes}~\ref{lst:model_questoes}:

\begin{lstlisting}[caption={código da classe Projeto},
label={lst:model_projeto}]
package br.com.gostoudaaula.model;

import java.io.Serializable;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.OneToOne;

import org.hibernate.validator.constraints.NotEmpty;

@Entity
public class Projeto implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Long id;
	private String descricao;
	private Avaliacao avaliacao;
	private List<Questoes> questoes;

	public Projeto() {
	}

	@NotEmpty
	public String getDescricao() {
		return descricao;
	}

	public void setDescricao(String descricao) {
		this.descricao = descricao;
	}

	@OneToOne(mappedBy = "projeto", cascade = CascadeType.PERSIST)
	public Avaliacao getAvaliacao() {
		return avaliacao;
	}

	public void setAvaliacao(Avaliacao avaliacao) {
		this.avaliacao = avaliacao;
	}

	@ManyToMany(cascade = CascadeType.PERSIST)
	@JoinTable(name = "questoes_projeto", joinColumns = { @JoinColumn(name = "id_projeto") }, inverseJoinColumns = {
			@JoinColumn(name = "id_questoes") })
	public List<Questoes> getQuestoes() {
		return questoes;
	}

	public void setQuestoes(List<Questoes> questoes) {
		this.questoes = questoes;
	}

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

}
\end{lstlisting}

\begin{lstlisting}[caption={código da classe Questoes},
label={lst:model_questoes}]
package br.com.gostoudaaula.model;

import java.io.Serializable;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;

import org.hibernate.validator.constraints.NotEmpty;

@Entity
public class Questoes implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Long id;
	private String descricao;
	private List<Projeto> projetos;

	public Questoes() {

	}

	@NotEmpty
	public String getDescricao() {
		return descricao;
	}

	public void setDescricao(String descricao) {
		this.descricao = descricao;
	}

	@ManyToMany(mappedBy = "questoes")
	public List<Projeto> getProjetos() {
		return projetos;
	}

	public void setProjetos(List<Projeto> projetos) {
		this.projetos = projetos;
	}

	@Id
	@GeneratedValu(strategy = GenerationType.IDENTITY)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

}
\end{lstlisting}

Note que ambas as classes possuem uma referência uma da outra. Durante o
processo de serialização esse tipo de referência pode ser problemático, pois,
nesse exemplo, se um objeto \textbf{X} do tipo \lstinline{Projeto} possuir a
referência para um objeto \textbf{Y} do tipo \lstinline{Questoes} e, esse mesmo
objeto \textbf{Y} tiver uma referência para o objeto \textbf{X} fará com que o
processo de serialização entre num estado chamado de circular reference, que é
justamente um looping infinito durante a serialização.\\ 

Uma maneira para resolver esse problema é justamente a utilização de mixins,
como por exemplo o mixin \lstinline{QuestoesMixIn}~\ref{lst:questoes_mixin}:

\begin{lstlisting}[caption={código da classe QuestoesMixIn},
label={lst:questoes_mixin}]
package br.com.gostoudaaula.json.mixin;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;

import br.com.gostoudaaula.model.Projeto;

@JsonAutoDetect(fieldVisibility = Visibility.NONE, getterVisibility = Visibility.NONE)
public class QuestoesMixIn {

	public class MainMixIn extends QuestoesMixIn {

		@JsonProperty
		private Long id;
		@JsonProperty
		private String descricao;
		@JsonProperty
		private List<Projeto> projetos;

	}

	public class AssociationMixIn extends QuestoesMixIn {
		@JsonProperty
		private Long id;
		@JsonProperty
		private String descricao;
	}
}
\end{lstlisting}

Observe que dentro da classe \lstinline{QuestoesMixIn} temos subclasses que
herdam dela, nesse caso a \lstinline{MainMixIn} e a
\lstinline{AssociationMixIn}. Cada uma dessas subclasses podem ser utilizadas no
momento da serialização do objeto do tipo \lstinline{Questoes}, por exemplo, se
eu quero apenas os atributos contidos na subclasse \lstinline{MainMixIn} basta
utilizar essa subclasse no momento da serialização.


\subsection{Converters}
\label{converters}

Todas as classes de converter estão contidas no pacote
\lstinline{br.com.gostoudaaula.converter}. Esses converters são classes que
servem apenas para conversão de dados que utilizam padrões diferentes. Como
exemplo, a data no Brasil que utiliza o Padrão \textbf{dd/mm/yyyy}, sendo que,
o padrão internacional é \textbf{yyyy/mm/dd}. Nesse projeto utilizamos o
converter para converte o tipo dos atributos para datas das classes
models~\ref{models} para o tipo suportado pelo banco de dados. Nesse caso da
classe \lstinline{Localdate} para \lstinline{Date}. Podemos ver a implementação
desse converter a partir da classe
\lstinline{DateConverter}~\ref{lst:date_converter}:


\begin{lstlisting}[caption={código da classe DateConverter},
label={lst:date_converter}]
package br.com.gostoudaaula.converter;

import java.sql.Date;
import java.util.TimeZone;

import javax.persistence.AttributeConverter;
import javax.persistence.Converter;

import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;

@Converter(autoApply = true)
public class DateConverter implements AttributeConverter<LocalDate, Date> {

	public Date convertToDatabaseColumn(LocalDate attribute) {
		return new Date(attribute.toDate().getTime());
	}

	public LocalDate convertToEntityAttribute(Date dbData) {
		return new LocalDate(dbData.getTime(),
				DateTimeZone.forTimeZone(TimeZone.getDefault()));
	}

}
\end{lstlisting}

\section{Utilização do Web Services REST}

A partir do Spring MVC podemos fazer com que os controllers também atuem como um
Web Service utilizando a arquitetura REST~\cite{}

