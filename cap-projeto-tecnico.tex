\chapter{Projeto Técnico}
\label{cap:projet/home/alex-felipe/git/monografia-gostoudaaula/cap-conceitos-e-tecnologia.texo_tecnico}

\section{Modelagem de banco de dados}
\label{sec:modelagem_de_banco_de_dados}

A aplicação \emph{Gostou da Aula?} teve seu desenvolvimento iniciado pela
modelagem conceitual dos dados. Após análise detalhada, obtivemos um Diagrama
Entidade Relacionamento, o qual é exibido pela figura ~\ref{fig:der}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{DER.jpg}
  \caption{Diagrama Entidade Relacionamento - DER}
  \label{fig:der}.
\end{figure}

Cada entitidade e relacionamento possui determinadas peculiaridades que são
descritas a seguir:

\begin{itemize}
  \item \textbf{Usuário}: Refere a uma representação de um usuário qualquer no
  sistema, essa é uma entidade abstrata, ou seja, exige uma especilização entre
  a entidade \textbf{Professor} e \textbf{Aluno} que são os 2 tipos de usuários
  existentes na aplicação.
  \item \textbf{Professor}: Representa um professor dentro da aplicação.
  \item \textbf{Aluno}: Representa um aluno dentro da aplicação.
  \item \textbf{Aula}: Representa uma aula dentro da aplicação, é constituída
  por \textbf{Aluno(os)}, um \textbf{Professor} e um \textbf{Periodo}.
  \item \textbf{Periodo}: Representa um período letivo dentro da instituição, é
  constituído por uma \textbf{Disciplina} e uma \textbf{Turma}.
  \item \textbf{Turma}: Representa uma turma da instituição.
  \item \textbf{Disciplina}: Representa uma disciplina da instituição.
  \item \textbf{Avaliacao}: Representa uma avaliação dentro da aplicação, é
  constituída por uma \textbf{Aula}, um \textbf{Projeto} e
  \textbf{Resposta(as)}.
  \item \textbf{Projeto}: Representa um projeto dentro da aplicação constituído
  por \textbf{Questoes} das avaliações.
  \item \textbf{Questoes}: Representa todas as questões de um determinado
  \textbf{Projeto}.
  \textbf{Respostas}: Representa todas as respostas de \textbf{Questoes} e
  \textbf{Avaliacao}.
\end{itemize} 

\section{Criação do projeto via Maven}
\label{sec:cricao_do_projeto_via_maven}

Para a criação do projeto, foi utilizada a biblioteca do
Maven~\ref{subsec:maven}. Há diversos modos para a criação de um projeto
utilizando a biblioteca do Maven, como por exemplo o terminal, porém, para essa
aplicação foi utilizado o Eclipse IDE~\ref{subsec:eclipse_ide_for_java_ee}, pois
ele já contém algumas facilidades, como por exemplo, escolher os menus de
criação em um modo gráfico e simplesmente digitar as informações necessárias sem
ao menos ficar escrevendo vários comandos. \ 

Para criar um projeto Maven no eclipse, basta clicar no menu ``File > New >
Project\ldots'', então aparecerá a janela conforme a figura
~\ref{fig:projeto_filtro_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project1.png}
  \caption{filtrando projetos com ``Maven'' no Eclipse IDE}
  \label{fig:projeto_filtro_maven}.
\end{figure}

Então escolhemos a opção ``Maven Project'' que exibe a janela conforme a
figura~\ref{fig:projeto_criacao_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project2.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_criacao_maven}.
\end{figure}

Lembre-se de deixar marcada a opção ``Create a simple project (skip archetype
selection)'' justamente para avançar o passo em que seleciona o archetype do
Maven~\cite{archetype} que é descrito com mais detalhes no link disponibilizado
na bibliografia.Então clicamos em ``Next'' e aparece a janela de acordo com 
a figura~\ref{fig:projeto_informacoes_maven} :

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project3.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_informacoes_maven}.
\end{figure}

Observe que agora é necessário adicionar algumas informações do Maven, que é
justamente o \textit{\textbf{Group Id}}, \textit{\textbf{Artifact Id}},
\textit{\textbf{Version}} e \textit{\textbf{Package}}. Cada uma das informações
possuem uma grande importante para aplicação. As descrições de cada um desses
itens estão disponíveis com detalhes no link disponibilizado na
bibliografia~\cite{namingmaven}.

Após a criação, o projeto Maven padrão criado pelo Eclipse contém a estrutura de
acordo com a figura~\ref{fig:projeto_maven_padrao}.

\begin{figure}[H]
  \centering 
  \includegraphics[width=0.7\textwidth]{project_explorer_for_maven.png}
  \caption{Estrutura do projeto Maven padrão criado pelo Eclipse}
  \label{fig:projeto_maven_padrao}.
\end{figure}

Basicamente, o diretório \textbf{src} é o local onde colocaremos todos os
arquivos fonte do projeto, como por exemplo, código, properties ou
qualquer arquivo de recurso da aplicação. Podemos observar que a estrutura
desse diretório contém mais dois subdiretórios: \textbf{main} e
\textbf{test}. Cada um desses subdiretório possuem objetivos e escopos
diferentes, que são descritos a seguir:

\begin{itemize}
  \item \textbf{main}: Todos os arquivos principais da aplicação, isto é,
  qualquer implementação destinada à aplicação, serão adicionados dentro desse
  diretório.
  \item \textbf{test}: Todos os arquivos de teste da aplicação, em outras
  palavras, qualquer tipo de código para realizar os testes da aplicação.
\end{itemize}

Além desses dois diretórios, para cada um deles, existem os subdiretórios
\textbf{java} e \textbf{resources} com os seguintes objetos:

\begin{itemize}
  \item \textbf{java}: Todos os arquivos de extensão .java, em outras palavras,
  todo código relacionado à classes Java, serão adicionados dentro desse
  diretório.
  \item \textbf{resources}: Todos os recursos da aplicação, como por exemplo,
  configurações em XML, .properties ou qualquer tipo de recurso para a aplicação
  que seja diferente de um arquivo de extensão .java, será adicionado nesse
  diretório.
\end{itemize}

\subsection{Utilizando modulos com Maven}
\label{subsec:utilizando_modulos_com_maven}

A arquitetura para o desenvolvimento da aplicação, foi planejado com a ideia da
criação de módulos~\ref{subsubsec:modularizacao_de_projeto}. Para essa aplicação
foram criados 3 módulos:

\begin{itemize}
  \item \textbf{core}: Adicionar as classes de regra de negócio representadas
  no diagrama de classes~\ref{sec:diagrama_de_classes}.
  \item \textbf{db}: Todas as classes para conexão com o banco de dados.
  \item \textbf{web}: Todas as classes e configuração para aplicação Web e
  configuração de conexão ao banco de dados.
\end{itemize}

Tendo conhecimento que cada projeto é independente um do outro, um dos pontos
importantes é saber como eles se comunicam entre eles. No Maven, utilizamos o
conceito Parent e childs descritos~\ref{subsec:parent_e_childs_com_maven}.

\subsection{Parent e childs com Maven}
\label{subsec:parent_e_childs_com_maven}

O conceito de parent e childs do Maven é justamente criar um projeto pai
(parent) e seus filhos (childs). O projeto pai, é um projeto genérico que não
possui código fonto ou qualquer arquivo de configuração. Ele é utilizado como
\textit{container} de seus filhos que de fato, são os módulos da aplicação.
Paara essa aplicação utilizamos também o mesmo nome de projeto para o parent,
porém com o sufixo \textbf{parent}.\\

Para configurar um projeto parent, simplesmente adicionamos os módulos no
pom.xml conforme o código~\ref{lst:adicao_de_modulos}:

\begin{lstlisting}[caption = {Adicionando módulos no projeto parent}, label
={lst:adicao_de_modulos}] 
	<modules>
		<module>
			gostoudaaula-core
		</module>
		<module>
			gostoudaaula-web
		</module>
		<module>gostoudaaula-db</module>
	</modules>
\end{lstlisting}

Além de informar ao parent quais são os seus módulos, todos os filhos precisam
também informar quem é o pai deles dentro do pom.xml adicionando o código:

\begin{lstlisting}[caption = {Adicionando o parent dentro de um módulo},
label={lst:adicao_de_parent}]
	<parent>
		<groupId>br.com.gostoudaaula</groupId>
		<artifactId>gostoudaaula-parent</artifactId>
		<version>0.1.9-SNAPSHOT</version>
	</parent>
\end{lstlisting}

A partir do momento em que um projeto Maven declara quem é o seu pai, todos os
recursos e dependências do pai são herdados a ele, ou seja, suas dependências e
arquivos de configurações. Porém, mesmo os modulos sendo filhos do mesmo pai,
não significa que cada um tem acesso direto ao outro, para resolver isso basta
adicionar os módulos necessários em cada projeto como uma
dependência~\ref{subsubsec:gerenciamento_de_dependencia}.




\section{Dependências de todos os módulos}
\label{sec:dependencias_de_todos_os_modulos}

Uma das grandes vantagens em utilizar o Maven é justamente pelo gerenciamento de
dependência~\ref{subsubsec:gerenciamento_de_dependencia}. Visto na
subseção~\ref{subsec:utilizando_modulos_com_maven}, a aplicação é baseada em
módulos que representam um projeto independemente, logo, cada um desses projetos possuem
suas respectivas dependências, e serão disponibilizadas a seguir:

\begin{itemize}
  \item \textbf{parent}~\ref{lst:dependencias_parent}:
  \begin{lstlisting}[caption = {Dependências do parent}, label =
  {lst:dependencias_parent}] 
  	<dependencies>
		<!-- Teste -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest-core</artifactId>
			<version>1.3</version>
			<scope>test</scope>
		</dependency>

		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
			<optional>true</optional>
		</dependency>

		<!-- data -->
		<dependency>
			<groupId>joda-time</groupId>
			<artifactId>joda-time</artifactId>
			<version>2.9</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{core}~\ref{lst:dependencias_core}: 
  \begin{lstlisting}[caption = {Dependências do core}, label =
  {lst:dependencias_core}]
  	<dependencies>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>


		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>

		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt</artifactId>
			<version>1.9.2</version>
		</dependency>

	</dependencies>  
  \end{lstlisting}
  \item \textbf{db}~\ref{lst:dependencias_db}:
  \begin{lstlisting}[caption = {Dependências do db}, label =
  {lst:dependencias_db}]
  	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>

		<!-- Spring data -->
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-jpa</artifactId>
			<version>1.9.2.RELEASE</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{web}~\ref{lst:dependencias_web}:
  \begin{lstlisting}[caption = {Dependências do web}, label = {lst:dependencias_web}] 
  	<dependencies>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-db</artifactId>
			<version>${project.version}</version>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<version>9.2-1003-jdbc4</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.25</version>
		</dependency>

		<!-- Básicas -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>xml-apis</groupId>
			<artifactId>xml-apis</artifactId>
			<version>1.4.01</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>


		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
		</dependency>

		<!-- Spring MVC -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${spring.version}</version>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Gerais -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.4</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-email</artifactId>
			<version>1.4</version>
		</dependency>
		<dependency>
			<groupId>commons-codec</groupId>
			<artifactId>commons-codec</artifactId>
			<version>1.10</version>
		</dependency>
		<dependency>
			<groupId>net.sargue</groupId>
			<artifactId>java-time-jsptags</artifactId>
			<version>1.0.0</version>
		</dependency>

		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>2.6.3</version>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
		</dependency>
	</dependencies>  
  \end{lstlisting}
\end{itemize}

\section{Diagramas de UML utilizados} 
\label{sec:diagramas_de_uml_utilizados}

No planejamento para a implementação da aplicação, utilizamos a
UML~\ref{subsec:uml} para representar de uma forma mais clara o que tinha que
ser implementado dentro da aplicação. Dentre os diversos diagramas existentes da
UML, foram utilizados apenas os diagramas de
\textbf{classes}~\ref{subsec:diagrama_de_classes_utilizado},\textbf{caso de
uso}~\ref{subsec:diagrama_de_caso_de_uso_utilizado} e de \textbf{sequência}.

\subsection{Diagrama de classes utilizado}
\label{subsec:diagrama_de_classes_utilizado}

Em projetos de aplicações orientadas a objetos, antes mesmo de começar a
implementar as classes, é muito comum utilizarmos o diagrama de
classes~\ref{subsubsec:diagrama_de_classes} para uma visibilidade estática de
como devemos implementar as classes.
Para essa aplicação utilizamos o diagrama de classe conforme a figura~\ref{fig:diagrama_de_classes}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_classes.png}
  \caption{Diagrama de classes}
  \label{fig:diagrama_de_classes}.
\end{figure}

\subsection{Diagrama de caso de uso utilizado}
\label{subsec:diagrama_de_caso_de_uso_utilizado}

Além do diagrama de classe~\ref{subsec:diagrama_de_classes_utilizado}, é de
grande importância utilizarmos o diagrama de caso de
uso~\ref{subsubsec:diagrama_de_caso_de_uso} para obtermos uma visão macro sobre
as principais funcionalidades. Para essa aplicação, utilizamos o diagrama
conforme a figura~\ref{fig:diagrama_de_caso_de_uso}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_caso_de_uso.png}
  \caption{Diagrama de caso de uso}
  \label{fig:diagrama_de_caso_de_uso}.
\end{figure}

\subsection{Diagrama de sequência utilizado}
\label{subsec:diagrama_de_sequencia_utilizado}

Dentre as funcionalidades apresentadas no diagrama de caso de
uso~\ref{fig:diagrama_de_caso_de_uso}, a principal funcionalidade é a
\textbf{avaliar aula} que possui diversos passos para que seja realizada, porém,
para especificar tal funcionalidade utilizamos o diagrama de
sequência~\ref{subsubsec:diagrama_de_sequencia} conforme a
figura~\ref{fig:diagrama_de_sequencia}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_sequencia.png}
  \caption{Diagrama de sequência para a funcionalidade \textbf{avaliar aula}}
  \label{fig:diagrama_de_sequencia}.
\end{figure}

\section{Configurando projeto web}
\label{sec:configurando_projeto_web}

\subsection{Configurando o Spring MVC}
\label{subsec:configura_o_spring_mvc}

O projeto web foi baseado na estrutura do Spring
MVC~\ref{subsec:spring_framework}, porém, a configuração inicial é realizada
dentro do arquivo ``src/main/webapp/views/web.xml'' que refere-se ao arquivo de
configuração da estrutura de um projeto Java Web. Dentro desse arquivo temos a
capacidade de configurar diversos comportamentos da aplicação, como por exemplo,
quais Servlets~\ref{subsec:servlet_api} serão utilizadas, qual endereço HTTP
será atendido dentre outros recursos. Para esse projeto foi utilizado o seguinte
XML~\ref{lst:web.xml_app_web} de configuração:

\begin{lstlisting}[caption={web.xml completo da aplicação web},
label={lst:web.xml_app_web}]
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0">
	<display-name>gostou da aula?</display-name>

	<servlet>
        <servlet-name>spring mvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <multipart-config>
            <max-file-size>500</max-file-size>
            <max-request-size>1000</max-request-size>
        </multipart-config>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring mvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>
\end{lstlisting}

Essa configuração descreve qual será a Servlet do Spring que será utilizada,
juntamente com a localização dessa Servlet. Além disso, descreve a partir de
qual endereço o Spring atuará, nesse caso, pra todo endereço que fizer parte da
``/'' (qualquer endereço via HTTP) será atendido pelo Spring, por fim, a
configuração de encoding que é justamente a formatação dos caracteres, para esse
projeto foi utilizado o UTF-8.\\

Com o arquivo web.xml configurado, precisamos criar o arquivo de configuração do
próprio Spring, que atuará como o projeto Spring MVC. Como visto no
código~\ref{lst:web.xml_app_web} a localização e nome do arquivo corresponde ao
seguinte valor: \textbf{classpath:spring/spring-mvc.xml}. Isso significa que
esse arquivo será procurado dentro do diretório:
``src/main/resources/spring/'', então criamos o arquivo \textbf{spring-mvc.xml}
com o conteúdo de acordo com o código:

\begin{lstlisting}[caption={spring-mvc.xml completo da aplicação web},
label={lst:spring-mvc.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc
	http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd 
	http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<mvc:annotation-driven />

	<mvc:default-servlet-handler />
	<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	<context:component-scan base-package="br.com.gostoudaaula" />

	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>

	<import resource="spring-jpa-config.xml" />
	<import resource="spring-flyway-config.xml" />
	<import resource="spring-ioc.xml" />
</beans>
\end{lstlisting}

O arquivo spring-mvc.xml concentra todas as configuração relacionadas ao Spring
MVC, como por exemplo o código~\ref{lst:configurando_mapeamento_de_paginas}:

\begin{lstlisting}[caption={configuração para o Spring mapear e acessar as
páginas web com extensões .jsp~\cite{jsp}},
label={lst:configurando_mapeamento_de_paginas}]
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
\end{lstlisting}
 
Além das configurações do Spring MVC, foram adicionadas as configurações de injeção de dependência~\ref{subsec:injecao_de_dependencia} do Spring
Framework, JPA~\ref{subsec:jpa_java_persistence_api} e
Hibernate~\ref{subsec:hibernate} e mensageria. Cada configuração está contida em
arquivos distintos que dentro do mesmo diretório do arquivo spring-mvc.xml. Abaixo serão
listado os arquivos com suas finalidades e sua configuração:

\begin{itemize}
  \item \textbf{spring-jpa-config.xml}: Todas as
  configurações relacionadas à configuração da JPA por meio da implementação do
  hibernate e o HikariCP~\ref{subsec:hikari_cp}. Toda a configuração está
  descrita no código:
  \begin{lstlisting}[caption={spring-jpa-config.xml completo da aplicação web},
  label={lst:spring-jpa-config.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
     http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

	<tx:annotation-driven transaction-manager="jpaTransactionManager" />

	<bean id="hibernateJpaVendorAdapter"
		class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter" />

	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
		depends-on="flyway">

		<property name="persistenceUnitName" value="${jpa.persistenceUnitName}" />
		<property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" />
		<property name="packagesToScan" value="${jpa.packagesToScan}" />

		<property name="jpaPropertyMap">
			<map>
				<entry key="hibernate.dialect" value="${hibernate.dialect}" />
				<entry key="hibernate.enable_lazy_load_no_trans" value="true" />

				<entry key="hibernate.show_sql" value="${hibernate.show_sql}" />
				<entry key="hibernate.format_sql" value="${hibernate.format_sql}" />

				<entry key="hibernate.connection.provider_class" value="${hibernate.connection.provider.class}" />
				<entry key="hibernate.hikari.dataSourceClassName" value="${hikari.datasource.class}" />
				<entry key="hibernate.hikari.dataSource.user" value="${hikari.datasource.user}" />
				<entry key="hibernate.hikari.dataSource.password" value="${hikari.datasource.password}" />
				<entry key="hibernate.hikari.dataSource.url" value="${hikari.datasource.url}" />

				<entry key="hibernate.hikari.maximumPoolSize" value="${hikari.pool.maxSize}" />
				<entry key="hibernate.hikari.connectionTimeout" value="${hikari.pool.timeOut}" />
				<entry key="hibernate.hikari.poolName" value="${hikari.pool.name}" />

				<entry key="hibernate.hikari.dataSource.cachePrepStmts" value="${hikari.ds.cache.prepStmts}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSize"
					value="${hikari.ds.cache.size}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSqlLimit"
					value="${hikari.ds.cache.sqlLimit}" />
				<entry key="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy" />
			</map>
		</property>
	</bean>

	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	<!-- configuração do spring data -->
	<jpa:repositories base-package="br.com.gostoudaaula.db"
		entity-manager-factory-ref="entityManagerFactory"
		transaction-manager-ref="jpaTransactionManager" 
		/>
</beans>
  \end{lstlisting}
   \item \textbf{spring-flyway-config.xml}: Todas as
  configurações relacionadas à integração do flyway~\ref{subsec:flyway} com o
  banco de dados. Toda a configuração está descrita no código:
  \begin{lstlisting}[caption={spring-flyway-config.xml completo da aplicação
  web}, label={lst:spring-flyway-config.xml_completo_da_app}]
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	
		<bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate">
			<property name="schemas" value="${flyway.schemas}" />
			<property name="encoding" value="${flyway.encoding}" />
			<property name="dataSource" ref="dataSource" />
			<property name="initOnMigrate" value="true" />
		</bean>
	
		<bean id="dataSource"
			class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="driverClassName" value="${flyway.datasource.class}" />
			<property name="url" value="${flyway.datasource.url}" />
			<property name="username" value="${flyway.datasource.username}" />
			<property name="password" value="${flyway.datasource.password}" />
		</bean>
	
	</beans>
  \end{lstlisting}
   \item \textbf{spring-ioc.xml}: Todas as configurações realacionadas a
   injeção de dependência~\ref{subsec:injecao_de_dependencia} aplicando o
   conceito de inversão de controle~\ref{subsec:inversao_de_controle}.
   Toda a configuração está descrita no código:
     \begin{lstlisting}[caption={spring-ioc.xml completo da aplicação
  web}, label={lst:spring-ioc.xml_completo_da_app}]
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
	    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	    http://www.springframework.org/schema/context
	    http://www.springframework.org/schema/context/spring-context-3.0.xsd
	    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd ">
	
	
		<context:property-placeholder
			file-encoding="UTF-8"
			location="classpath:properties/general.properties, classpath:properties/database.properties,
		 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	
		<context:annotation-config></context:annotation-config>
		<context:component-scan base-package="br.com.gostoudaaula" />
	
		<bean id="ObjectMapper" class="com.fasterxml.jackson.databind.ObjectMapper"
			scope="request">
			<aop:scoped-proxy />
		</bean>
	
		<import resource="spring-flyway-config.xml" />
		<import resource="spring-jpa-config.xml" />
	
	</beans>
     \end{lstlisting}
\end{itemize}

\subsection{Propriedades do projeto}
\label{subsec:propriedades_do_projeto}

Em alguns beans do Spring MVC, os valores foram atribuídos por meio expression
language~\cite{el}, como por exemplo o bean do flyway~\ref{lst:bean_flyway}:

\begin{lstlisting}[caption={bean do flyway}, label={lst:bean_flyway}]
<bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate">
	<property name="schemas" value="${flyway.schemas}" />
	<property name="encoding" value="${flyway.encoding}" />
	<property name="dataSource" ref="dataSource" />
	<property name="initOnMigrate" value="true" />
</bean>
	
\end{lstlisting}

Observe que para a \textit{property} schemas, foi atribuído o valor
\textit{\$\{flyway.schemas\}}. Esses valores são extraídos a partir de arquivos
properties~\cite{properties}. Nesse projeto, para que o Spring MVC consiga
encontrar e ler os arquivos properties, e então, extrair seus valores, foi
definido o caminho
\textbf{classpath:properties}
dentro do arquivo
\textbf{spring-mvc.xml}~\ref{lst:spring-mvc.xml_completo_da_app}. Para definir o
caminho basta apenas adicionar a tag \textbf{<context:property-placeholder />}
informando o \textit{enconding} dos arquivos e a locatização de todos os
arquivos que serão lidos. Podemos ver uma demonstração utilizada nesse projeto a
partir do código~\ref{lst:property_placeholder}:


\begin{lstlisting}[caption={property-placeholder do projeto},
label={lst:property_placeholder}]
<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	
\end{lstlisting}

Observe que temos 4 arquivos distintos dentro do projeto. Cada arquivo contém
informações relacionadas a um tipo de configuração, por exemplo:

\begin{itemize}
  \item \textbf{general.properties:} Definições gerais do projeto.
  \item \textbf{database.properties:} Definições do banco de dados.
  \item \textbf{flyway.properties:} Definições do flyway.
  \item \textbf{jpa.properties:} Definições da JPA.
\end{itemize}

Como exemplo veremos o conteúdo do \textbf{general.properties} a partir do
código~\ref{lst:conteudo_do_general.properties}:

\begin{lstlisting}[caption={conteúdo do general.properties},
label={lst:conteudo_do_general.properties}]	
#Configurações gerais
encoding = UTF-8
url = ${url}
\end{lstlisting}

\subsection{Configurando flyway}
\label{subsec:configurando_flyway}

Além das definições realizadas pelo flyway, é necessária a existência de um
arquivo SQL para que ele consiga gerenciar as migrations do banco de dados.
Porém, no flyway, precisamos seguir uma convenção para que ele consiga gerenciar
da forma adequada. Nesse projeto foi utilizado apenas um único arquivo com o
seguinte nome \lstinline{V1__Criacao_tabelas_base.sql}.\\

Note que o arquivo contém \textbf{V1} que indica a versão, nesse caso, é a
versão 1, então é adicionado 2 \textit{underscores} e, em seguida, o nome do
arquivo de uma forma bem verbosa, ou seja, explicando explicítamente o que ele
significa e por fim adicionando a extensão SQL.\\

O conteúdo desses arquivos são instruções SQL, ou seja, toda a instrução contida
nesse arquivo V1 será executada assim que o flyway for executado. Caso seja
necessário algum tipo de modificação no banco de dados, basta criar um novo
arquivo com somando 1 com a versão final, por exemplo, a versão atual é a 1, a
próxima seria V2 e assim sucessivamente.\\

Para esse projeto, todos esses arquivos do flyway precisam ser inseridos no
\textbf{classpath:db/migration}.

\section{Estrutura do projeto web}
\label{sec:estrutura_do_projeto_web}

\subsection{Controllers do Spring}
\label{subsec:controllers_do_spring}

No projeto web, para inicializarmos a aplicação a partir de uma arquitetura
MVC~\ref{subsec:mvc_model_view_controller} começamos pela criação de
controllers. Nesse projeto, adicionamos todas as classes de controller no
pacote: \textbf{br.com.gostoudaaula.controller}.\\

Para criar uma classe que representa um controller, é recomendado a utilização
da seguinte convenção: \textit{NomeDaClasseController}, ou seja, o nome da
classe junto com o prefixo ~\textit{Controller}. Por exemplo, nesse projeto, o
controller que representa a página de vísita, isto é, a página inicial foi
denominado como \lstinline{SiteController}, podemos ver o seu conteúdo a partir
do código~\ref{lst:site_controller}:

\begin{lstlisting}[caption={código da classe SiteController},
label={lst:site_controller}]	
package br.com.gostoudaaula.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import static org.springframework.web.bind.annotation.RequestMethod.GET;

@Controller
@RequestMapping("/")
public class SiteController {

	@RequestMapping(method = GET)
	public String index() {
		return "index";
	}
}
\end{lstlisting}

Observe que esse controller contém duas annotations~\cite{annotations}:

\begin{itemize}
  \item \textbf{@Controller:} Indica que a classe será um controller do Spring
  MVC
  \item \textbf{@RequestMapping:} Indica que a partir da URL ``/'', esse
  controller irá atender.
\end{itemize}

Além disso, o método \lstinline{index} também está anotado com um
\lstinline{@RequestMapping}, porém, diferente da annotation da classe que recebe
uma string como valor, essa contém um atributo \lstinline{method} com o valor
\lstinline{GET}. Isso significa que, se a requisição for para a ``/'' e o método
de requisição do HTTP~\cite{requestmethod} for GET, esse método será atendido.\\

Além disso, observe que esse método retorna uma String com o valor ``index'',
isso significa que o Spring MVC tentará encontrar uma página dentro do projeto
no diretório \textbf{src/main/webapp/WEB-INF/views} com a extensão .jsp conforme
a configuração do arquivo spring-mvc.xml~\ref{lst:spring-mvc.xml_completo_da_app}

\subsection{Services do Spring}
\label{subsec:services_do_spring}

No modelo MVC o controller é o responsável em receber as informações do
cliente, e então, delegar para um especialista, ou seja, uma classe capaz de
realizar a tarefa solicitada. Teoricamente, se ele receber uma requisição para
cadastrar algum objeto, significa que ele precisa passar a diante para uma
classe que faça a persistência de dados, ou então, se a requisição é para apenas
validar dados, enviará para uma classe que faça isso.\\

Mesmo sendo funcional, tal prática dentro de um controller não é recomendável,
justamente pelo controller ser responsável em apenas delegar. Em outras
palavras, controllers não se comunicam diretamente com essas classes
específicas, e sim, delegam tais tarefas para classes conhecidas como services.
Dentro do Spring, os services são basicamente uma camada que fica entre a parte
lógica (persistência de dados, validação, tratamento e geral) e o controller
para resolver qualquer tipo de requição para uma entidade, por exemplo, se é
necessário cadastrar uma turma, ou até mesmo validá-la, enviamos tal
requisição para um service que conterá todas as funcionalidades da entidade
turma.\\

No Spring, para criarmos um service, seguimos a seguinte convenção:
\textit{NomeDaClasseService}, ou seja, o nome da
classe junto com o prefixo ~\textit{Service}. Nesse projeto, todas as services
foram adicionadas no pacote \textbf{br.com.gostoudadaula.service}. Como exemplo,
veremos o service \lstinline{TurmaService} a partir do
código~\ref{lst:turma_service}, que representa um service exclusivo da entidade
turma:

\begin{lstlisting}[caption={código da classe TurmaController},
label={lst:turma_service}]	
package br.com.gostoudaaula.service;

import javax.inject.Inject;

import org.springframework.stereotype.Service;

import br.com.gostoudaaula.db.repository.TurmaRepository;
import br.com.gostoudaaula.model.Turma;

@Service
public class TurmaService {

	private TurmaRepository repository;

	@Inject
	public TurmaService(TurmaRepository repository) {
		this.repository = repository;
	}

	public void salva(Turma turma) {
		repository.save(turma);
	}

	public Turma retorna(Turma turma) {
		return repository.findOne(turma.getId());
	}

}
\end{lstlisting}

Além do nome da classe ter o prefixo \textit{Service}, observe que também
precisamos adicionar a annotation \lstinline{@Service} para indicar ao Spring
que essa classe será gerenciada por ele como um service. 

\section{Estrutura do projeto db}
\label{sec:estrutura_do_projeto_db}

\subsection{Utilizando o Spring Data}
\label{subsec:utilizando_o_spring_data}

No projeto db, ao invés de utilizarmos classes com o design pattern DAO (Data
Access Object)~\cite{dao}, a partir do módulo Spring
Data~\ref{subsec:spring_data}, nesse projeto foi utilizado o conceito de
repositories Spring Data~\cite{repositoriesspring}. No Spring,
repositories são representações de classes onde ocorre a persistência de
dados. A princípio existe uma certa similiaridade com classes DAO, entretanto,
no Spring Data, representamos um repository a partir de uma interface que
estende de classes fornecidas pelo Spring Data.\\

A representação mais básica para um repository é a partir da classe
\lstinline{CrudRepository<T,ID extends Serializable>}~\cite{crudrepository} que
já contém métodos de CRUD (Create Read Update and Delete), ou seja, métodos que são bem comuns durante uma implementação de um
DAO. A vantagem em utilizar esse tipo de abordagem é justamente o ganho em
produtividade, pois, dessa forma, evitamos de ficar escrevendo diversas linhas
de código que fazem rotinas em comum, como por exemplo, inserção de dados.\\

Nesse projeto, adicionamos todos os repositories dentro do pacote
\textbf{br.com.gostoudaaula.db.repository}. Podemos ver  um exemplo de
um repository a partir da interface \lstinline{RespostasRepository} a partir do
código~\ref{lst:respostas_repository}:

\begin{lstlisting}[caption={código da interface RespostasRepository},
label={lst:respostas_repository}]
package br.com.gostoudaaula.db.repository;

import java.util.List;
import org.joda.time.LocalDate;
import org.springframework.data.repository.CrudRepository;
import br.com.gostoudaaula.model.Avaliacao;
import br.com.gostoudaaula.model.Respostas;

public interface RespostasRepository extends CrudRepository<Respostas, Long>{

	Respostas findByData(LocalDate localDate);

	public List<Respostas> findByAvaliacao(Avaliacao avaliacao);
}
\end{lstlisting}

Nesse repository, representamos a interface que fará todas as transações com o
banco de dados para a classe modelo \lstinline{Respostas}. Observe que no
momento em que a interface é estendida, passamos dois valores como
generics~\cite{generics}, que significa o tipo da classe que será persistida e o
tipo do seu id. Nesse caso a classe \lstinline{Respostas} é a classe que será
persistida e o \lstinline{Long} é o tipo do id da classe dentro do banco de
dados.\\

Além dos métodos CRUDs que são fornecidos pela classe
\lstinline{CrudRepository<T,ID extends Serializable>}, observe que a classe
\lstinline{RespostasRepository} contém mais duas assinaturas. Essas assinaturas
são alternativas de busca de registros para a classe \lstinline{Respostas}
dentro do banco de dados, por exemplo, a assinatura \lstinline{findByData}
indica que queremos retornar um objeto do tipo \lstinline{Respostas} a partir do
atributo chamado ``data'' dentro da classe \lstinline{Respostas} com o tipo
\lstinline{LocalDate}.\\

\section{Estrutura do projeto core}
\label{sec:estrutura_do_projeto_core}

No projeto core, foram adicionadas todas as classes modelos, DTOs~\cite{dto},
mixins do Jackson~\ref{subsec:jackson} e conversores. 

\subsection{Models}
\label{subsec:models}

Todas as classes modelos estão contidas
no pacote \lstinline{br.com.gostoudaaula.model} onde cada classe representa uma
entidade do sistema. Como por exemplo a classe \lstinline{Disciplina} a partir
do código~\ref{lst:model_disciplina}:

\begin{lstlisting}[caption={código da classe Disciplina},
label={lst:model_disciplina}]
package br.com.gostoudaaula.model;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

import org.hibernate.validator.constraints.NotEmpty;

@Entity
public class Disciplina implements Serializable {

	private static final long serialVersionUID = 1L;
	private Long id;
	private String descricao;

	public Disciplina() {
	}

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	@NotEmpty
	public String getDescricao() {
		return descricao;
	}

	public void setDescricao(String descricao) {
		this.descricao = descricao;
	}

}
\end{lstlisting}

Observe que essa classe contém anotações da JPA justamente por se tratar de uma
representação de uma disciplina no banco de dados do projeto. 

\subsection{DTO}
\label{subsec:dto}

Todas as classes DTO estão contidas no pacote
\lstinline{br.com.gostoudaaula.dto}. A partir dessas classes podemos transferir
dados de formas de uma forma diferente ao qual contemos em classes
models~\ref{subsec:models}, justamente para atender a uma necessidade que apenas
o conteúdo contido em uma entidade não seja o suficiente. Nesse projeto, temos
apenas a classe \lstinline{PeriodoDTO} como exemplo, podemos ver o seu conteúdo
a partir do código~\ref{lst:periodo_dto}:

\begin{lstlisting}[caption={código da classe PeriodoDTO},
label={lst:periodo_dto}]
package br.com.gostoudaaula.dto;

import javax.persistence.Convert;

import org.joda.time.LocalDate;
import org.springframework.format.annotation.DateTimeFormat;

import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

import br.com.gostoudaaula.converter.DateConverter;
import br.com.gostoudaaula.json.LocalDateDeserializer;
import br.com.gostoudaaula.json.LocalDateSerializer;
import br.com.gostoudaaula.model.PeriodoLetivo;

public class PeriodoDTO {

	LocalDate inicio;
	LocalDate fim;
	PeriodoLetivo periodoLetivo;

	public PeriodoDTO() {
	}

	public PeriodoDTO(PeriodoLetivo periodoLetivo, LocalDate inicio, LocalDate fim) {
		this.periodoLetivo = periodoLetivo;
		this.inicio = inicio;
		this.fim = fim;
	}

	@DateTimeFormat(pattern = "dd/MM/yyyy")
	@Convert(converter = DateConverter.class)
	@JsonSerialize(using = LocalDateSerializer.class)
	@JsonDeserialize(using = LocalDateDeserializer.class)
	public LocalDate getInicio() {
		return inicio;
	}

	public void setInicio(LocalDate inicio) {
		this.inicio = inicio;
	}

	@DateTimeFormat(pattern = "dd/MM/yyyy")
	@Convert(converter = DateConverter.class)
	@JsonSerialize(using = LocalDateSerializer.class)
	@JsonDeserialize(using = LocalDateDeserializer.class)
	public LocalDate getFim() {
		return fim;
	}

	public void setFim(LocalDate fim) {
		this.fim = fim;
	}

	public PeriodoLetivo getPeriodoLetivo() {
		return periodoLetivo;
	}

	public void setPeriodoLetivo(PeriodoLetivo periodoLetivo) {
		this.periodoLetivo = periodoLetivo;
	}

}
\end{lstlisting}

Observe que essa classe contém apenas atributos e e anotações para conversão de
de atributos para documentos JSON. Portanto, essas classes são utilizadas apenas
para transferirmos dados.

\subsection{Mixins do Jackson}
\label{subsec:mixins_do_jackson}

Todos os mixins estão contidos no pacote
\lstinline{br.com.gostoudaaula.json.mixins}. Mixins são classes auxiliares
durante a serialização de um objeto a partir da biblioteca do Jackson. A partir
dos mixins, podemos limitar os atributos que serão serializados em qualquer tipo
de classe, ou seja, caso algum tipo de atributo seja delicado, como por exemplo,
uma senha, ou então, por algum motivo qualquer não seja preferível que um
atributo de uma determinada classe seja serializado, podemos utilizar os mixins
para resolver esse problema.\\

Nesse projeto, além da situação em que não era interessante um determinado
atributo durante a serialização, também utilizamos os mixins justamente para os
casos em que temos relacionamentos bidirecionais na utilização da JPA. Como por
exemplo as classes \lstinline{Projeto}~\ref{lst:model_projeto} e
\lstinline{Questoes}~\ref{lst:model_questoes}:

\begin{lstlisting}[caption={código da classe Projeto},
label={lst:model_projeto}]
package br.com.gostoudaaula.model;

import java.io.Serializable;
import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.OneToOne;

import org.hibernate.validator.constraints.NotEmpty;

@Entity
public class Projeto implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Long id;
	private String descricao;
	private Avaliacao avaliacao;
	private List<Questoes> questoes;

	public Projeto() {
	}

	@NotEmpty
	public String getDescricao() {
		return descricao;
	}

	public void setDescricao(String descricao) {
		this.descricao = descricao;
	}

	@OneToOne(mappedBy = "projeto", cascade = CascadeType.PERSIST)
	public Avaliacao getAvaliacao() {
		return avaliacao;
	}

	public void setAvaliacao(Avaliacao avaliacao) {
		this.avaliacao = avaliacao;
	}

	@ManyToMany(cascade = CascadeType.PERSIST)
	@JoinTable(name = "questoes_projeto", joinColumns = { @JoinColumn(name = "id_projeto") }, inverseJoinColumns = {
			@JoinColumn(name = "id_questoes") })
	public List<Questoes> getQuestoes() {
		return questoes;
	}

	public void setQuestoes(List<Questoes> questoes) {
		this.questoes = questoes;
	}

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

}
\end{lstlisting}

\begin{lstlisting}[caption={código da classe Questoes},
label={lst:model_questoes}]
package br.com.gostoudaaula.model;

import java.io.Serializable;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;

import org.hibernate.validator.constraints.NotEmpty;

@Entity
public class Questoes implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Long id;
	private String descricao;
	private List<Projeto> projetos;

	public Questoes() {

	}

	@NotEmpty
	public String getDescricao() {
		return descricao;
	}

	public void setDescricao(String descricao) {
		this.descricao = descricao;
	}

	@ManyToMany(mappedBy = "questoes")
	public List<Projeto> getProjetos() {
		return projetos;
	}

	public void setProjetos(List<Projeto> projetos) {
		this.projetos = projetos;
	}

	@Id
	@GeneratedValu(strategy = GenerationType.IDENTITY)
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

}
\end{lstlisting}

Note que ambas as classes possuem uma referência uma da outra. Durante o
processo de serialização esse tipo de referência pode ser problemático, pois,
nesse exemplo, se um objeto \textbf{X} do tipo \lstinline{Projeto} possuir a
referência para um objeto \textbf{Y} do tipo \lstinline{Questoes} e, esse mesmo
objeto \textbf{Y} tiver uma referência para o objeto \textbf{X} fará com que o
processo de serialização entre num estado chamado de circular reference, que é
justamente um looping infinito durante a serialização.\\ 

Uma maneira para resolver esse problema é justamente a utilização de mixins,
como por exemplo o mixin \lstinline{QuestoesMixIn}~\ref{lst:questoes_mixin}:

\begin{lstlisting}[caption={código da classe QuestoesMixIn},
label={lst:questoes_mixin}]
package br.com.gostoudaaula.json.mixin;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;

import br.com.gostoudaaula.model.Projeto;

@JsonAutoDetect(fieldVisibility = Visibility.NONE, getterVisibility = Visibility.NONE)
public class QuestoesMixIn {

	public class MainMixIn extends QuestoesMixIn {

		@JsonProperty
		private Long id;
		@JsonProperty
		private String descricao;
		@JsonProperty
		private List<Projeto> projetos;

	}

	public class AssociationMixIn extends QuestoesMixIn {
		@JsonProperty
		private Long id;
		@JsonProperty
		private String descricao;
	}
}
\end{lstlisting}

Observe que dentro da classe \lstinline{QuestoesMixIn} temos subclasses que
herdam dela, nesse caso a \lstinline{MainMixIn} e a
\lstinline{AssociationMixIn}. Cada uma dessas subclasses podem ser utilizadas no
momento da serialização do objeto do tipo \lstinline{Questoes}, por exemplo, se
eu quero apenas os atributos contidos na subclasse \lstinline{MainMixIn} basta
utilizar essa subclasse no momento da serialização.


\subsection{Converters}
\label{subsec:converters}

Todas as classes de converter estão contidas no pacote
\lstinline{br.com.gostoudaaula.converter}. Esses converters são classes que
servem apenas para conversão de dados que utilizam padrões diferentes. Como
exemplo, a data no Brasil que utiliza o Padrão \textbf{dd/mm/yyyy}, sendo que,
o padrão internacional é \textbf{yyyy/mm/dd}. Nesse projeto utilizamos o
converter para converte o tipo dos atributos para datas das classes
models~\ref{subsec:models} para o tipo suportado pelo banco de dados. Nesse caso
da classe \lstinline{Localdate} para \lstinline{Date}. Podemos ver a implementação
desse converter a partir da classe
\lstinline{DateConverter}~\ref{lst:date_converter}:


\begin{lstlisting}[caption={código da classe DateConverter},
label={lst:date_converter}]
package br.com.gostoudaaula.converter;

import java.sql.Date;
import java.util.TimeZone;

import javax.persistence.AttributeConverter;
import javax.persistence.Converter;

import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;

@Converter(autoApply = true)
public class DateConverter implements AttributeConverter<LocalDate, Date> {

	public Date convertToDatabaseColumn(LocalDate attribute) {
		retpenurn new Date(attribute.toDate().getTime());
	}

	public LocalDate convertToEntityAttribute(Date dbData) {	
		return new LocalDate(dbData.getTime(),
				DateTimeZone.forTimeZone(TimeZone.getDefault()));
	}

}
\end{lstlisting}

\section{Utilização do Web Services REST}

A partir do Spring MVC, podemos fazer com que os controllers também atuem como
um Web Service utilizando a arquitetura REST~\ref{subsubsec:rest}.
Para isso basta apenas fazer uso da biblioteca de serialização do Jackson. Por
exemplo, dentro do controller
\lstinline{ProfessorController} temos o método
\lstinline{getTurmas}~\ref{lst:metodo_getturmas}:

\begin{lstlisting}[caption={método getTumas do ProfessorController},
label={lst:metodo_getturmas}]
@Controller
@RequestMapping("professor")
public class ProfessorController {

	private ProfessorService professorService;
	private ObjectMapper mapper;

	@Inject
	public ProfessorController(ProfessorService professorService, ObjectMapper mapper) {
		this.professorService = professorService;
		this.mapper = mapper;
	}
	
	@RequestMapping(value = "turmas/{id}", method = GET, produces = JSON)
	public ResponseEntity<String> getTurmas(Professor professor) throws JsonProcessingException {
		String json = mapper.writeValueAsString(professorService.getTurmas(professor));
		return new ResponseEntity<String>(json, HttpStatus.OK);
	}
	
	// restante do código

\end{lstlisting}

Observe que esse método devolve a classe \lstinline{ResponseEntity<T>} que é uma
API do Spring para respondermos requisições com qualquer tipo de objeto. Dessa
forma, podemos fazer com que qualquer objeto seja devolvido como um documento
JSON. Portanto, ao utilizamos essa classe, estabelecemos um mecanismo de
comunicação via JSON utilizando o protocolo HTTP.\\

Além disso, nesse projeto, para toda utilização da classe
\lstinline{ResponseEntity}, foi utilizada a devolução apenas de String. Em
outras palavras, ao invés de deixar o Spring responsável em converter objetos
para JSON, preferimos realizar esse procedimento manualmente, portanto, em todos
os métodos que utilizamos para esse tipo de comunicação, desenvolvemos Strings,
que representam o arquivo JSON já configurado. O principal motivo para essa
escolha é justamente pela questão de utilizar os mixins do
jackson~\ref{subsec:mixins_do_jackson} para evitar o problema da referêcia
circular.

\section{Utilização da plataforma openshift}
\label{sec:utilizacao_da_plataforma_openshift}

Para distribuir a aplicação, utilizamos o Openshift da Red
Hat~\ref{subsec:openshift}. Justamente pela questão de funcionar em uma
arquitetura baseada em computação nas nuvens. Portanto, não temos a necessidade
de conhecer a infraestrutura do servidor(es) que funciona(m) por de trás dos
panos.\\

Além de não ter que se preocupar em configurar uma infraestrutura
capaz para manter uma aplicação Java Web funcionando, também temos alguns
benefícios ao utilizar o openshift.

\begin{itemize}
  \item \textbf{Custo}: Podemos criar até 3 aplicações em um plano gratuito onde
  não exige um cartão de crédito.
  \item \textbf{Estrutura do projeto}: Para aplicações Java Web, o
  openshift utiliza a estrutura de projeto do Maven~\ref{subsec:maven}. Dessa
  forma, podemos utilizar o nosso próprio projeto sem a necessidade de diversas
  configurações a mais.
  \item \textbf{Realização do deploy via Git}: Para a distribuição da aplicação,
  o openshift utiliza o git~\ref{subsec:git}.
\end{itemize}

\subsection{RHC} 

A integração do cliente (desenvolvedor) com a plataforma do openshift, é por
meio do da ferramenta de linha de comando rhc que pode ser instalada em diversos
sistemas operacionais. O link de instalação está disponibilizado na
bibliografia~\cite{instalacaorhc}.\\

A partir do momento em que realiza a instalação do rhc, o openshift gera uma
chave pública com o protocolo SSH~\cite{ssh} que vincula com a conta do
openshift. Dessa forma, é possível realizarmos qualquer interação com a
plataforma, como por exemplo, o download da aplicação que foi criada, ou então,
a criação de aplicações utilizando o terminal.

\subsection{Configuração da aplicação dentro do openshift}
\label{subsec:configuracao_da_aplicacao_dentro_do_openshift}

Dentro da plataforma do openshift, podemos criar diversas aplicações a partir do seu
console~\cite{consoleopenshift} com o link disponibilizado a partir da
bibliografia. Cada aplicação pode ser composta por um tipo de container, que é
justamente o servidor que manterá a aplicação funcionando, para esse projeto,
foi utilizado o servidor de aplicação Tomcat~\cite{tomcat}. Além do Tomcat, foi
necessário a utilização de um banco de dados e uma interface gráfica para seu
acesso. Sendo mais preciso, foram utilizadas as seguintes especificações para o
projeto do openshift:

\begin{itemize}
  \item \textbf{Tomcat 7}: Servidor de aplicação.
  \item \textbf{MySQL 5.5}: Banco de dados.
  \item \textbf{phpMyAdmin 4.0}: Interface gráfica ao banco de dados.
\end{itemize}

\subsection{Download e Deploy da aplicação}
\label{subsec:download_e_deploy_da_aplicacao}

Após a criação da aplicação, dentro do console do openshift, é disponibilizado
um endereço em SSH para a realização do download do projeto. O download é
realizado por meio do git~\ref{subsec:git}, para isso, dentro de um prompt de
comando no windows ou um terminal em sistemas Linux ou Mac OSX, basta apenas
utilizar o comando \lstinline{git clone link_ssh_do_projeto}. A partir da
execução desse comando, será realizado o donwload no diretório em que
executar.\\

Se o projeto tiver as mesmas configurações citadas na
seção~\ref{subsec:configuracao_da_aplicacao_dentro_do_openshift}, será um
projeto maven com algumas configurações dentro do \textbf{pom.xml} necessárias
para que seja possível realizar o deploy da aplicação. Além disso, dentro da
pasta do projeto baixado, contém 2 diretórios ocultos:

\begin{itemize}
  \item \textbf{.openshift}: arquivos de configuração do projeto dentro da
  plataforma do openshift.
  \item \textbf{.git}: arquivo de configuração do git para controlar o
projeto.
\end{itemize} 

Em outras palavras, após o momento em que realizamos o download, precisamos,
pelo menos, manter esses subdiretórios para que consigámos realizar a distribuição do
projeto. Para o deploy do projeto, é necessário apenas fazer o
procedimento normal de push do git~\cite{pushgit}. Durante o processo de deploy,
o openshift executa diversas rotinas que chegam a reiniciar o serviço que mantém
a aplicação ativa, portanto, é sempre interessante analisar melhores horários
para realizar o deploy da aplicação, justamente para não impactar a experiência
de todos os clientes que consomem a aplicação.\\

\section{Estrutura do projeto Android}
\label{sec:estrutura_do_projeto_android}

Embora o núcleo da aplicação tenha sido desenvolvido como um projeto Java Web em
um servidor na nuvem, a interface gráfica do usuário, também conhecida,
tecnicamente, como GUI (Graphical User Interface), foi desenvolvida para
dispositivos móveis que operam com o sistema operacional Android~\cite{android}. Para esse projeto,
utilizamos a ferramenta Android Studio~\ref{subsec:android_studio} que é
disponibilizada gratuitamente no site de desenvolvedores
Android~\cite{android_developers}.\\

Para qualquer projeto desenvolvido em cima do Android Studio, é criado e
gerenciado pelo Gradle~\ref{subsec:gradle}. A partir dele podemos realizar
qualquer tipo de configuração necessária para o projeto, como por exemplo,
definir a versão mínima e máxima do Android, adicionar ou remover dependências
entre demais configurações mais avançadas que não serão vistas nesse documento,
entretanto, podem ser consultadas no link~\cite{gradle_android} disponibilizado
na bibliografia.

\subsection{Versão do Android}
\label{subsec:versao_do_android}

Durante a criação do projeto Android é necessária a escolha da versão mínima que
a App estará funcionará. Para esse projeto,
escolhemos a versão mínima \textbf{sugerida do Android Studio} que é a
\textbf{API 15:
Android 4.0.3 (IceCreamSandwish)} com 97,4\% dos dispositivos ativos da play store comforme a figura~\ref{fig:janela_config_minima_android}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{janela_de_versao_minima_android.png}
  \caption{Janela de configuração mínima do Android Studio}
  \label{fig:janela_config_minima_android}.
\end{figure}

\subsection{Dependências do projeto Android}
\label{subsec:dependencias_do_projeto_android}

Embora as APIs disponibilizadas nativamente pelo SDK (Software Development Kit)
do Android, já resolvam diversos problemas dentro de um projeto Android, a
utilização das mesmas nem sempre é tão preferível, justamente pela falta de
facilidade durante a implementação. Pensando justamente nesse ponto entre
outros, foi necessária a utilização de bibliotecas externas, ou melhor,
dependências do projeto, para o desenvolvimento da App ser mais eficaz. Todas as
dependências do projeto foram adicionadas e gerenciadas pelo Gradle a partir do
arquivo \textbf{build.gradle} no nível da App. O
código~\ref{lst:dependencias_android} lista todas as dependências utilizadas:

\begin{lstlisting}[caption={Dependências do projeto Android},
label={lst:dependencias_android}]
dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:23.1.1'
    compile 'com.github.lecho:hellocharts-library:1.5.8@aar'
    compile 'br.com.gostoudaaula:gostoudaaula-core:0.1.9-SNAPSHOT'
    compile 'com.squareup.okhttp:okhttp:2.7.0'
    compile 'com.fasterxml.jackson.core:jackson-databind:2.6.3'
    compile 'com.jakewharton:butterknife:7.0.1'
}
\end{lstlisting}

O Objetivo de cada dependencia é explicado na lista abaixo:
x
\begin{itemize}
  \item \textbf{com.github.lecho:hellocharts-library:1.5.8@aar} Criação de
  gráficos em Android.
  \item \textbf{br.com.gostoudaaula:gostoudaaula-core:0.1.9-SNAPSHOT} Projeto
  core da aplicação para a reutilização das mesmas classes modelos.
  \item \textbf{com.squareup.okhttp:okhttp:2.7.0} Comunicação via protocolo
  HTTP.
  \item \textbf{com.fasterxml.jackson.core:jackson-databind:2.6.3} Serialização
  e deserialização de objetos para documentos JSON.
  \item \textbf{com.jakewharton:butterknife:7.0.1} Injeção de View.
\end{itemize}

\section{Funcionalidades da aplicação Android}
\label{sec:funcionalidades_da_aplicacao_android}

Embora a App contenha diversas funcionalidades diferentes, muitas delas são bem
comuns dentro de um projeto de desenvolvimento de software, como por exemplo, o
login, a listagem aulas, disciplinas, matérias e até mesmo a listagem das
avaliações de cada aula. Entretanto, existem algumas funcionalidades que são um
pouco mais complexas e que exigiram um pouco mais de atenção durante o
desenvolvimento. Como por exemplo, a funcionalidade que permite o aluno a
avaliar uma avaliação independentemente da quantidade de perguntas que uma
avaliação contenha, e também, a geração do gráfico para o resultado final da
avaliação.

\subsection{Respondendo avaliação}
\label{subsec:respondendo_avaliacao}

O objetivo principal dentro do projeto Android é permitir que cada
aluno consiga realizar a avaliação de uma aula. Mesmo parecendo um problema
trivial, essa funcionalidade exige alguns cuidados, pois em um cenário mais
complexo, ou seja, onde podemos conter diversas perguntas para uma avaliação,
provavelmente, não é recomendado a utilização de uma única
Activity~\cite{android_activity}, pois podemos ter uma única tela enorme que
pode confundir o aluno durante o processo de avaliação, ou então, fazendo com
que ele esqueça de avaliar alguma questão.\\

Pensando nessa questão, uma maneira mais conveniente de solucionar
esse problema é justamente criar uma tela exclusiva para cada questão.
Entretanto, uma Activity para cada questão é mais problemático ainda, pois o
custo computacional, ou melhor, a exigência em performance e memória do celular
será enorme. Considerando essa situação, a recomendação da Google é a utilização
de Fragments~\cite{android_fragments}. Portanto, para essa funcionalidade, foi
utilizada a classe \lstinline{QuestoesFragment} do pacote
\textbf{br.com.gostoudaaula.fragment} que é exibida a partir do
Código~\ref{lst:classe_questoesfragment}.

\begin{lstlisting}[caption={Classe QuestoesFragment},
label={lst:classe_questoesfragment}]
package br.com.gostoudaaula.fragment;

import android.app.Fragment;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.RatingBar;
import android.widget.TextView;

import org.joda.time.LocalDate;

import java.util.ArrayList;

import br.com.gostoudaaula.R;
import br.com.gostoudaaula.delegate.QuestoesDelegate;
import br.com.gostoudaaula.model.Avaliacao;
import br.com.gostoudaaula.model.Questoes;
import br.com.gostoudaaula.model.Respostas;
import butterknife.Bind;
import butterknife.ButterKnife;
import butterknife.OnClick;

/**
 * Created by alexf on 25/01/16.
 */
public class QuestoesFragment extends Fragment {

    @Bind(R.id.questoes_pergunta)
    TextView pergunta;
    @Bind(R.id.questoes_resposta)
    RatingBar rating;
    @Bind(R.id.questoes_botao_responder)
    Button button;
    @Bind(R.id.questoes_quantidade)
    TextView quantidade;
    private int total;
    private int questaoAtual;
    private ArrayList<Questoes> questoes;
    private ArrayList<Respostas> respostas;
    private int valueRating;
    private Avaliacao avaliacao;
    private QuestoesDelegate delegate;
    private Questoes questao;

    private void setup(Bundle bundle) {
        this.avaliacao = (Avaliacao) bundle.getSerializable("avaliacao");
        this.questoes = (ArrayList<Questoes>) avaliacao.getProjeto().getQuestoes();
        this.total = questoes.size();
        this.questaoAtual = bundle.getInt("questao_atual");
        this.questao = questoes.get(questaoAtual);
        this.respostas = (ArrayList<Respostas>) bundle.getSerializable("respostas");
        this.valueRating = 0;
        if (respostas == null) {
            respostas = new ArrayList<>();
        } else if (respostas.size() == questaoAtual + 1) {
            this.valueRating = respostas.get(questaoAtual).getResposta();
        }
        this.delegate = (QuestoesDelegate) getActivity();
        setTitle("Questões");
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle bundle) {
        setup(getArguments());
        View view = inflater.inflate(R.layout.fragment_questoes, container, false);
        ButterKnife.bind(this, view);
        populaViews();
        return view;
    }

    private void populaViews() {
        pergunta.setText(questao.getDescricao());
        quantidade.setText(this.questaoAtual + 1 + " de " + total);
    }

    private void proximaQuestao() {
        this.delegate.proximaQuestao(this.avaliacao, this.respostas);
    }

    @OnClick(R.id.questoes_botao_responder)
    public void responde() {
        insereResposta();
        if (questaoAtual + 1 < total)
            proximaQuestao();
        else
            delegate.enviaRespostas(respostas);
    }

    private void insereResposta() {
        valueRating = rating.getProgress();
        Respostas respostaAtual = new Respostas();
        respostaAtual.setResposta(valueRating);
        respostaAtual.setQuestoes(questoes.get(questaoAtual));
        respostaAtual.setData(LocalDate.now());
        respostas.add(respostaAtual);
    }

    private void setTitle(String title) {
        getActivity().setTitle(title);
    }

}
\end{lstlisting}

A partir desse Fragment é possível exibir todas as questões, sendo que,
cada uma delas, tenham uma tela exclusiva sem que aja a necessidade de iniciar
novas activities, independemente da quantidade de questões que serão
respondidas. As partes principais para que esse Fragment funcione da forma
esperada são os métodos \lstinline{setup()}, \lstinline{responde()},
\lstinline{insereResposta()} que contém as seguintes responsabilidades:

\begin{itemize}
  \item \textbf{setup()}: Inicializar o estado atual da questão atual junto com
  o seu total e sua respectiva resposta.
  \item \textbf{responde()}: A partir desse é possível fazer com que o aluno
  avançe para a próxima questão, caso o número da questão atual seja menor que a
  quantidade total.
  \item \textbf{insereResposta()}: Quando esse método é chamado, indica que a
  questão atual será preenchida com as informações contidas na tela. Por
  exemplo, se o aluno der nota 5 para a primeira questão e nota 7 para a
  segunda, é esse método que irá garantir que isso seja possível.
\end{itemize}

\subsection{Representação de resultados}
\label{subsec:representacao_de_resultados}

O objetivo de cada avaliação é permitir a extração de um resultado sobre o que
foi avaliado, como por exemplo, saber quais foram as notas de uma aula. Existem
diversas formas de representar o resultado de uma avaliação, desde texto a
representações visuais como diagramas ou gráficos. Para esse projeto, foi
utilizada uma representação em gráfico torre onde podemos ver um exemplo a
partir da Figura~\ref{fig:grafico_app_android}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{grafico_app_android.jpg}
  \caption{Gráfico da aula de programação do dia 02/04/2016 na App Android}
  \label{fig:grafico_app_android}.
\end{figure}

Observe que o gráfico mostra a quantidade total de notas independentemente da
pergunta que foi respondida, ou seja, se uma avaliação conter 3 questões, e
apenas um único aluno responder, serão computadas 3 questões, se forem 2 alunos
6 questões e assim sucessivamente. Em outras palavras, para esse gráfico, o
total de respostas a serem computadas dependerá da quantidade de questões da
avaliação e a quantidade de alunos que avaliarem, isto é, quantidade de questões
multiplicada pela quantidade de alunos.\\

Além disso, é possível notar que ao invés de mostrar a quantidade de notas
usando todos os índices possíveis, isto é, de 0 a 10, foi utilizada a
estratégia de agrupamento de notas, ou seja,  

Embora a representação do resultado da forma que está atualmente não seja tão
preciso, ou melhor, não passa o feedback exato sobre a qual questão cada
resposta representa, é possível obtermos o feedback geral sobre o conjunto, ou
seja, a partir desse gráfico, o professor é capaz de compreender que a aula, em
geral, foi boa ou ruim, independemente de onde ele teve melhor (notas altas) ou
pior (notas baixas) desempenho.
