\chapter{Projeto Técnico}
\label{cap:projet/home/alex-felipe/git/monografia-gostoudaaula/cap-conceitos-e-tecnologia.texo_tecnico}

\section{Modelagem de banco de dados}
\label{sec:modelagem_de_banco_de_dados}

A aplicação \emph{Gostou da Aula?} teve seu desenvolvimento iniciado pela
modelagem conceitual dos dados. Após análise detalhada, obtivemos um Diagrama
Entidade Relacionamento, o qual é exibido pela figura ~\ref{fig:der}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{DER.jpg}
  \caption{Diagrama Entidade Relacionamento - DER}
  \label{fig:der}.
\end{figure}

Cada entitidade e relacionamento possui determinadas peculiaridades que são
descritas a seguir:

\begin{itemize}
  \item \textbf{Usuário}: Refere a uma representação de um usuário qualquer no
  sistema, essa é uma entidade abstrata, ou seja, exige uma especilização entre
  a entidade \textbf{Professor} e \textbf{Aluno} que são os 2 tipos de usuários
  existentes na aplicação.
  \item \textbf{Professor}: Representa um professor dentro da aplicação.
  \item \textbf{Aluno}: Representa um aluno dentro da aplicação.
  \item \textbf{Aula}: Representa uma aula dentro da aplicação, é constituída
  por \textbf{Aluno(os)}, um \textbf{Professor} e um \textbf{Periodo}.
  \item \textbf{Periodo}: Representa um período letivo dentro da instituição, é
  constituído por uma \textbf{Disciplina} e uma \textbf{Turma}.
  \item \textbf{Turma}: Representa uma turma da instituição.
  \item \textbf{Disciplina}: Representa uma disciplina da instituição.
  \item \textbf{Avaliacao}: Representa uma avaliação dentro da aplicação, é
  constituída por uma \textbf{Aula}, um \textbf{Projeto} e
  \textbf{Resposta(as)}.
  \item \textbf{Projeto}: Representa um projeto dentro da aplicação constituído
  por \textbf{Questoes} das avaliações.
  \item \textbf{Questoes}: Representa todas as questões de um determinado
  \textbf{Projeto}.
  \textbf{Respostas}: Representa todas as respostas de \textbf{Questoes} e
  \textbf{Avaliacao}.
\end{itemize} 

\section{Criação do projeto via Maven}
\label{sec:cricao_do_projeto_via_maven}

Para a criação do projeto, foi utilizada a biblioteca do
Maven~\ref{subsec:maven}. Há diversos modos para a criação de um projeto
utilizando a biblioteca do Maven, como por exemplo o terminal, porém, para essa
aplicação foi utilizado o Eclipse IDE~\ref{subsec:eclipse_ide_for_java_ee}, pois
ele já contém algumas facilidades, como por exemplo, escolher os menus de
criação em um modo gráfico e simplesmente digitar as informações necessárias sem
ao menos ficar escrevendo vários comandos. \ 

Para criar um projeto Maven no eclipse, basta clicar no menu ``File > New >
Project\ldots'', então aparecerá a janela conforme a figura
~\ref{fig:projeto_filtro_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project1.png}
  \caption{filtrando projetos com ``Maven'' no Eclipse IDE}
  \label{fig:projeto_filtro_maven}.
\end{figure}

Então escolhemos a opção ``Maven Project'' que exibe a janela conforme a
figura~\ref{fig:projeto_criacao_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project2.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_criacao_maven}.
\end{figure}

Lembre-se de deixar marcada a opção ``Create a simple project (skip archetype
selection)'' justamente para avançar o passo em que seleciona o archetype do
Maven~\cite{archetype} que é descrito com mais detalhes no link disponibilizado
na bibliografia.Então clicamos em ``Next'' e aparece a janela de acordo com 
a figura~\ref{fig:projeto_informacoes_maven} :

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project3.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_informacoes_maven}.
\end{figure}

Observe que agora é necessário adicionar algumas informações do Maven, que é
justamente o \textit{\textbf{Group Id}}, \textit{\textbf{Artifact Id}},
\textit{\textbf{Version}} e \textit{\textbf{Package}}. Cada uma das informações
possuem uma grande importante para aplicação. As descrições de cada um desses
itens estão disponíveis com detalhes no link disponibilizado na
bibliografia~\cite{namingmaven}.

Após a criação, o projeto Maven padrão criado pelo Eclipse contém a estrutura de
acordo com a figura~\ref{fig:projeto_maven_padrao}.

\begin{figure}[H]
  \centering 
  \includegraphics[width=0.7\textwidth]{project_explorer_for_maven.png}
  \caption{Estrutura do projeto Maven padrão criado pelo Eclipse}
  \label{fig:projeto_maven_padrao}.
\end{figure}

Basicamente, o diretório \textbf{src} é o local onde colocaremos todos os
arquivos fonte do projeto, como por exemplo, código, properties ou
qualquer arquivo de recurso da aplicação. Podemos observar que a estrutura
desse diretório contém mais dois subdiretórios: \textbf{main} e
\textbf{test}. Cada um desses subdiretório possuem objetivos e escopos
diferentes, que são descritos a seguir:

\begin{itemize}
  \item \textbf{main}: Todos os arquivos principais da aplicação, isto é,
  qualquer implementação destinada à aplicação, serão adicionados dentro desse
  diretório.
  \item \textbf{test}: Todos os arquivos de teste da aplicação, em outras
  palavras, qualquer tipo de código para realizar os testes da aplicação.
\end{itemize}

Além desses dois diretórios, para cada um deles, existem os subdiretórios
\textbf{java} e \textbf{resources} com os seguintes objetos:

\begin{itemize}
  \item \textbf{java}: Todos os arquivos de extensão .java, em outras palavras,
  todo código relacionado à classes Java, serão adicionados dentro desse
  diretório.
  \item \textbf{resources}: Todos os recursos da aplicação, como por exemplo,
  configurações em XML, .properties ou qualquer tipo de recurso para a aplicação
  que seja diferente de um arquivo de extensão .java, será adicionado nesse
  diretório.
\end{itemize}

\subsection{Utilizando modulos com Maven}
\label{subsec:utilizando_modulos_com_maven}

A arquitetura para o desenvolvimento da aplicação, foi planejado com a ideia da
criação de módulos~\ref{subsubsec:modularizacao_de_projeto}. Para essa aplicação
foram criados 3 módulos:

\begin{itemize}
  \item \textbf{core}: Adicionar as classes de regra de negócio representadas
  no diagrama de classes~\ref{sec:diagrama_de_classes}.
  \item \textbf{db}: Todas as classes para conexão com o banco de dados.
  \item \textbf{web}: Todas as classes e configuração para aplicação Web e
  configuração de conexão ao banco de dados.
\end{itemize}

Tendo conhecimento que cada projeto é independente um do outro, um dos pontos
importantes é saber como eles se comunicam entre eles. No Maven, utilizamos o
conceito Parent e childs descritos~\ref{subsec:parent_e_childs_com_maven}.

\subsection{Parent e childs com Maven}
\label{subsec:parent_e_childs_com_maven}

O conceito de parent e childs do Maven é justamente criar um projeto pai
(parent) e seus filhos (childs). O projeto pai, é um projeto genérico que não
possui código fonto ou qualquer arquivo de configuração. Ele é utilizado como
\textit{container} de seus filhos que de fato, são os módulos da aplicação.
Paara essa aplicação utilizamos também o mesmo nome de projeto para o parent,
porém com o sufixo \textbf{parent}.\\

Para configurar um projeto parent, simplesmente adicionamos os módulos no
pom.xml conforme o código~\ref{lst:adicao_de_modulos}:

\begin{lstlisting}[caption = {Adicionando módulos no projeto parent}, label
={lst:adicao_de_modulos}] 
	<modules>
		<module>
			gostoudaaula-core
		</module>
		<module>
			gostoudaaula-web
		</module>
		<module>gostoudaaula-db</module>
	</modules>
\end{lstlisting}

Além de informar ao parent quais são os seus módulos, todos os filhos precisam
também informar quem é o pai deles dentro do pom.xml adicionando o código:

\begin{lstlisting}[caption = {Adicionando o parent dentro de um módulo},
label={lst:adicao_de_parent}]
	<parent>
		<groupId>br.com.gostoudaaula</groupId>
		<artifactId>gostoudaaula-parent</artifactId>
		<version>0.1.9-SNAPSHOT</version>
	</parent>
\end{lstlisting}

A partir do momento em que um projeto Maven declara quem é o seu pai, todos os
recursos e dependências do pai são herdados a ele, ou seja, suas dependências e
arquivos de configurações. Porém, mesmo os modulos sendo filhos do mesmo pai,
não significa que cada um tem acesso direto ao outro, para resolver isso basta
adicionar os módulos necessários em cada projeto como uma
dependência~\ref{subsubsec:gerenciamento_de_dependencia}.




\section{Dependências de todos os módulos}
\label{sec:dependencias_de_todos_os_modulos}

Uma das grandes vantagens em utilizar o Maven é justamente pelo gerenciamento de
dependência~\ref{subsubsec:gerenciamento_de_dependencia}. Visto na
subseção~\ref{subsec:utilizando_modulos_com_maven}, a aplicação é baseada em
módulos que representam um projeto independemente, logo, cada um desses projetos possuem
suas respectivas dependências, e serão disponibilizadas a seguir:

\begin{itemize}
  \item \textbf{parent}~\ref{lst:dependencias_parent}:
  \begin{lstlisting}[caption = {Dependências do parent}, label =
  {lst:dependencias_parent}] 
  	<dependencies>
		<!-- Teste -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest-core</artifactId>
			<version>1.3</version>
			<scope>test</scope>
		</dependency>

		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
			<optional>true</optional>
		</dependency>

		<!-- data -->
		<dependency>
			<groupId>joda-time</groupId>
			<artifactId>joda-time</artifactId>
			<version>2.9</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{core}~\ref{lst:dependencias_core}: 
  \begin{lstlisting}[caption = {Dependências do core}, label =
  {lst:dependencias_core}]
  	<dependencies>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>


		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>

		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt</artifactId>
			<version>1.9.2</version>
		</dependency>

	</dependencies>  
  \end{lstlisting}
  \item \textbf{db}~\ref{lst:dependencias_db}:
  \begin{lstlisting}[caption = {Dependências do db}, label =
  {lst:dependencias_db}]
  	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>

		<!-- Spring data -->
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-jpa</artifactId>
			<version>1.9.2.RELEASE</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{web}~\ref{lst:dependencias_web}:
  \begin{lstlisting}[caption = {Dependências do web}, label = {lst:dependencias_web}] 
  	<dependencies>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-db</artifactId>
			<version>${project.version}</version>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<version>9.2-1003-jdbc4</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.25</version>
		</dependency>

		<!-- Básicas -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>xml-apis</groupId>
			<artifactId>xml-apis</artifactId>
			<version>1.4.01</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>


		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
		</dependency>

		<!-- Spring MVC -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${spring.version}</version>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Gerais -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.4</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-email</artifactId>
			<version>1.4</version>
		</dependency>
		<dependency>
			<groupId>commons-codec</groupId>
			<artifactId>commons-codec</artifactId>
			<version>1.10</version>
		</dependency>
		<dependency>
			<groupId>net.sargue</groupId>
			<artifactId>java-time-jsptags</artifactId>
			<version>1.0.0</version>
		</dependency>

		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>2.6.3</version>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
		</dependency>
	</dependencies>  
  \end{lstlisting}
\end{itemize}

\section{Diagramas de UML utilizados} 
\label{sec:diagramas_de_uml_utilizados}

No planejamento para a implementação da aplicação, utilizamos a
UML~\ref{subsec:uml} para representar de uma forma mais clara o que tinha que
ser implementado dentro da aplicação. Dentre os diversos diagramas existentes da
UML, foram utilizados apenas os diagramas de
\textbf{classes}~\ref{subsec:diagrama_de_classes_utilizado},\textbf{caso de
uso}~\ref{subsec:diagrama_de_caso_de_uso_utilizado} e de \textbf{sequência}.

\subsection{Diagrama de classes utilizado}
\label{subsec:diagrama_de_classes_utilizado}

Em projetos de aplicações orientadas a objetos, antes mesmo de começar a
implementar as classes, é muito comum utilizarmos o diagrama de
classes~\ref{subsubsec:diagrama_de_classes} para uma visibilidade estática de
como devemos implementar as classes.
Para essa aplicação utilizamos o diagrama de classe conforme a figura~\ref{fig:diagrama_de_classes}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_classes.png}
  \caption{Diagrama de classes}
  \label{fig:diagrama_de_classes}.
\end{figure}

\subsection{Diagrama de caso de uso utilizado}
\label{subsec:diagrama_de_caso_de_uso_utilizado}

Além do diagrama de classe~\ref{subsec:diagrama_de_classes_utilizado}, é de
grande importância utilizarmos o diagrama de caso de
uso~\ref{subsubsec:diagrama_de_caso_de_uso} para obtermos uma visão macro sobre
as principais funcionalidades. Para essa aplicação, utilizamos o diagrama
conforme a figura~\ref{fig:diagrama_de_caso_de_uso}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_caso_de_uso.png}
  \caption{Diagrama de caso de uso}
  \label{fig:diagrama_de_caso_de_uso}.
\end{figure}

\subsection{Diagrama de sequência utilizado}
\label{subsec:diagrama_de_sequencia_utilizado}

Dentre as funcionalidades apresentadas no diagrama de caso de
uso~\ref{fig:diagrama_de_caso_de_uso}, a principal funcionalidade é a
\textbf{avaliar aula} que possui diversos passos para que seja realizada, porém,
para especificar tal funcionalidade utilizamos o diagrama de
sequência~\ref{subsubsec:diagrama_de_sequencia} conforme a
figura~\ref{fig:diagrama_de_sequencia}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_sequencia.png}
  \caption{Diagrama de sequência para a funcionalidade \textbf{avaliar aula}}
  \label{fig:diagrama_de_sequencia}.
\end{figure}

\section{Configurando projeto web}
\label{sec:configurando_projeto_web}

\subsection{Configurando o Spring MVC}
\label{subsec:configura_o_spring_mvc}

O projeto web foi baseado na estrutura do Spring
MVC~\ref{subsec:spring_framework}, porém, a configuração inicial é realizada
dentro do arquivo ``src/main/webapp/views/web.xml'' que refere-se ao arquivo de
configuração da estrutura de um projeto Java Web. Dentro desse arquivo temos a
capacidade de configurar diversos comportamentos da aplicação, como por exemplo,
quais Servlets~\ref{subsec:servlet_api} serão utilizadas, qual endereço HTTP
será atendido dentre outros recursos. Para esse projeto foi utilizado o seguinte
XML~\ref{lst:web.xml_app_web} de configuração:

\begin{lstlisting}[caption={web.xml completo da aplicação web},
label={lst:web.xml_app_web}]
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0">
	<display-name>gostou da aula?</display-name>

	<servlet>
        <servlet-name>spring mvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <multipart-config>
            <max-file-size>500</max-file-size>
            <max-request-size>1000</max-request-size>
        </multipart-config>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring mvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>
\end{lstlisting}

Essa configuração descreve qual será a Servlet do Spring que será utilizada,
juntamente com a localização dessa Servlet. Além disso, descreve a partir de
qual endereço o Spring atuará, nesse caso, pra todo endereço que fizer parte da
``/'' (qualquer endereço via HTTP) será atendido pelo Spring, por fim, a
configuração de encoding que é justamente a formatação dos caracteres, para esse
projeto foi utilizado o UTF-8.\\

Com o arquivo web.xml configurado, precisamos criar o arquivo de configuração do
próprio Spring, que atuará como o projeto Spring MVC. Como visto no
código~\ref{lst:web.xml_app_web} a localização e nome do arquivo corresponde ao
seguinte valor: \textbf{classpath:spring/spring-mvc.xml}. Isso significa que
esse arquivo será procurado dentro do diretório:
``src/main/resources/spring/'', então criamos o arquivo \textbf{spring-mvc.xml}
com o conteúdo de acordo com o código:

\begin{lstlisting}[caption={spring-mvc.xml completo da aplicação web},
label={lst:spring-mvc.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc
	http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd 
	http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<mvc:annotation-driven />

	<mvc:default-servlet-handler />
	<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	<context:component-scan base-package="br.com.gostoudaaula" />

	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>

	<import resource="spring-jpa-config.xml" />
	<import resource="spring-flyway-config.xml" />
	<import resource="spring-ioc.xml" />
</beans>
\end{lstlisting}

O arquivo spring-mvc.xml concentra todas as configuração relacionadas ao Spring
MVC, como por exemplo o código~\ref{lst:configurando_mapeamento_de_paginas}:

\begin{lstlisting}[caption={configuração para o Spring mapear e acessar as
páginas web com extensões .jsp~\cite{jsp}},
label={lst:configurando_mapeamento_de_paginas}]
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
\end{lstlisting}
 
Além das configurações do Spring MVC, foram adicionadas as configurações de injeção de dependência~\ref{subsec:injecao_de_dependencia} do Spring
Framework, JPA~\ref{subsec:jpa_java_persistence_api} e
Hibernate~\ref{subsec:hibernate} e mensageria. Cada configuração está contida em
arquivos distintos que dentro do mesmo diretório do arquivo spring-mvc.xml. Abaixo serão
listado os arquivos com suas finalidades e sua configuração:

\begin{itemize}
  \item \textbf{spring-jpa-config.xml}: Todas as
  configurações relacionadas à configuração da JPA por meio da implementação do
  hibernate e o HikariCP~\ref{subsec:hikari_cp}. Toda a configuração está
  descrita no código:
  \begin{lstlisting}[caption={spring-jpa-config.xml completo da aplicação web},
  label={lst:spring-jpa-config.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
     http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

	<tx:annotation-driven transaction-manager="jpaTransactionManager" />

	<bean id="hibernateJpaVendorAdapter"
		class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter" />

	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
		depends-on="flyway">

		<property name="persistenceUnitName" value="${jpa.persistenceUnitName}" />
		<property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" />
		<property name="packagesToScan" value="${jpa.packagesToScan}" />

		<property name="jpaPropertyMap">
			<map>
				<entry key="hibernate.dialect" value="${hibernate.dialect}" />
				<entry key="hibernate.enable_lazy_load_no_trans" value="true" />

				<entry key="hibernate.show_sql" value="${hibernate.show_sql}" />
				<entry key="hibernate.format_sql" value="${hibernate.format_sql}" />

				<entry key="hibernate.connection.provider_class" value="${hibernate.connection.provider.class}" />
				<entry key="hibernate.hikari.dataSourceClassName" value="${hikari.datasource.class}" />
				<entry key="hibernate.hikari.dataSource.user" value="${hikari.datasource.user}" />
				<entry key="hibernate.hikari.dataSource.password" value="${hikari.datasource.password}" />
				<entry key="hibernate.hikari.dataSource.url" value="${hikari.datasource.url}" />

				<entry key="hibernate.hikari.maximumPoolSize" value="${hikari.pool.maxSize}" />
				<entry key="hibernate.hikari.connectionTimeout" value="${hikari.pool.timeOut}" />
				<entry key="hibernate.hikari.poolName" value="${hikari.pool.name}" />

				<entry key="hibernate.hikari.dataSource.cachePrepStmts" value="${hikari.ds.cache.prepStmts}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSize"
					value="${hikari.ds.cache.size}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSqlLimit"
					value="${hikari.ds.cache.sqlLimit}" />
				<entry key="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy" />
			</map>
		</property>
	</bean>

	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	<!-- configuração do spring data -->
	<jpa:repositories base-package="br.com.gostoudaaula.db"
		entity-manager-factory-ref="entityManagerFactory"
		transaction-manager-ref="jpaTransactionManager" 
		/>
</beans>
  \end{lstlisting}
   \item \textbf{spring-flyway-config.xml}: Todas as
  configurações relacionadas à integração do flyway~\ref{subsec:flyway} com o
  banco de dados. Toda a configuração está descrita no código:
  \begin{lstlisting}[caption={spring-flyway-config.xml completo da aplicação
  web}, label={lst:spring-flyway-config.xml_completo_da_app}]
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	
		<bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate">
			<property name="schemas" value="${flyway.schemas}" />
			<property name="encoding" value="${flyway.encoding}" />
			<property name="dataSource" ref="dataSource" />
			<property name="initOnMigrate" value="true" />
		</bean>
	
		<bean id="dataSource"
			class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="driverClassName" value="${flyway.datasource.class}" />
			<property name="url" value="${flyway.datasource.url}" />
			<property name="username" value="${flyway.datasource.username}" />
			<property name="password" value="${flyway.datasource.password}" />
		</bean>
	
	</beans>
  \end{lstlisting}
   \item \textbf{spring-ioc.xml}: Todas as configurações realacionadas a
   injeção de dependência~\ref{subsec:injecao_de_dependencia} aplicando o
   conceito de inversão de controle~\ref{subsec:inversao_de_controle}.
   Toda a configuração está descrita no código:
     \begin{lstlisting}[caption={spring-ioc.xml completo da aplicação
  web}, label={lst:spring-ioc.xml_completo_da_app}]
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
	    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	    http://www.springframework.org/schema/context
	    http://www.springframework.org/schema/context/spring-context-3.0.xsd
	    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd ">
	
	
		<context:property-placeholder
			file-encoding="UTF-8"
			location="classpath:properties/general.properties, classpath:properties/database.properties,
		 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	
		<context:annotation-config></context:annotation-config>
		<context:component-scan base-package="br.com.gostoudaaula" />
	
		<bean id="ObjectMapper" class="com.fasterxml.jackson.databind.ObjectMapper"
			scope="request">
			<aop:scoped-proxy />
		</bean>
	
		<import resource="spring-flyway-config.xml" />
		<import resource="spring-jpa-config.xml" />
	
	</beans>
     \end{lstlisting}
\end{itemize}

\subsection{Propriedades do projeto}
\label{propriedades_do_projeto}

Em alguns beans do Spring MVC, os valores foram atribuídos por meio expression
language~\cite{el}, como por exemplo o bean do flyway~\ref{lst:bean_flyway}:

\begin{lstlisting}[caption={bean do flyway}, label={lst:bean_flyway}]
<bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate">
	<property name="schemas" value="${flyway.schemas}" />
	<property name="encoding" value="${flyway.encoding}" />
	<property name="dataSource" ref="dataSource" />
	<property name="initOnMigrate" value="true" />
</bean>
	
\end{lstlisting}

Observe que para a \textit{property} schemas, foi atribuído o valor
\textit{\$\{flyway.schemas\}}. Esses valores são extraídos a partir de arquivos
properties~\cite{properties}. Nesse projeto, para que o Spring MVC consiga
encontrar e ler os arquivos properties, e então, extrair seus valores, foi
definido o caminho
\textbf{classpath:properties}
dentro do arquivo
\textbf{spring-mvc.xml}~\ref{lst:spring-mvc.xml_completo_da_app}. Para definir o
caminho basta apenas adicionar a tag \textbf{<context:property-placeholder />}
informando o \textit{enconding} dos arquivos e a locatização de todos os
arquivos que serão lidos. Podemos ver uma demonstração utilizada nesse projeto a
partir do código~\ref{lst:property_placeholder}:


\begin{lstlisting}[caption={property-placeholder do projeto},
label={lst:property_placeholder}]
<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	
\end{lstlisting}

Observe que temos 4 arquivos distintos dentro do projeto. Cada arquivo contém
informações relacionadas a um tipo de configuração, por exemplo:

\begin{itemize}
  \item \textbf{general.properties:} Definições gerais do projeto.
  \item \textbf{database.properties:} Definições do banco de dados.
  \item \textbf{flyway.properties:} Definições do flyway.
  \item \textbf{jpa.properties:} Definições da JPA.
\end{itemize}

Como exemplo veremos o conteúdo do \textbf{general.properties} a partir do
código~\ref{lst:conteudo_do_general.properties}:

\begin{lstlisting}[caption={conteúdo do general.properties},
label={lst:conteudo_do_general.properties}]	
#Configurações gerais
encoding = UTF-8
url = ${url}
\end{lstlisting}

\subsection{Configurando flyway}
\label{subsec:configurando_flyway}

Além das definições realizadas pelo flyway, é necessária a existência de um
arquivo SQL para que ele consiga gerenciar as migrations do banco de dados.
Porém, no flyway, precisamos seguir uma convenção para que ele consiga gerenciar
da forma adequada. Nesse projeto foi utilizado apenas um único arquivo com o
seguinte nome \lstinline{V1__Criacao_tabelas_base.sql}.\\

Note que o arquivo contém \textbf{V1} que indica a versão, nesse caso, é a
versão 1, então é adicionado 2 \textit{underscores} e, em seguida, o nome do
arquivo de uma forma bem verbosa, ou seja, explicando explicítamente o que ele
significa e por fim adicionando a extensão SQL.\\

O conteúdo desses arquivos são instruções SQL, ou seja, toda a instrução contida
nesse arquivo V1 será executada assim que o flyway for executado. Caso seja
necessário algum tipo de modificação no banco de dados, basta criar um novo
arquivo com somando 1 com a versão final, por exemplo, a versão atual é a 1, a
próxima seria V2 e assim sucessivamente.\\

Para esse projeto, todos esses arquivos do flyway precisam ser inseridos no
\textbf{classpath:db/migration}.

\section{Estrutura do projeto web}
\label{sec:estrutura_do_projeto_web}

\subsection{Controllers do Spring}
\label{subsec:controllers_do_spring}

No projeto web, para inicializarmos a aplicação a partir de uma arquitetura
MVC~\ref{subsec:mvc_model_view_controller} começamos pela criação de
controllers. Nesse projeto, adicionamos todas as classes de controller no
pacote: \textbf{br.com.gostoudaaula.controller}.\\

Para criar uma classe que representa um controller, é recomendado a utilização
da seguinte convenção: \textit{NomeDaClasseController}, ou seja, o nome da
classe junto com o prefixo ~\textit{Controller}. Por exemplo, nesse projeto, o
controller que representa a página de vísita, isto é, a página inicial foi
denominado como \lstinline{SiteController}, podemos ver o seu conteúdo a partir
do código~\ref{lst:site_controller}:

\begin{lstlisting}[caption={código da classe SiteController},
label={lst:site_controller}]	
package br.com.gostoudaaula.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import static org.springframework.web.bind.annotation.RequestMethod.GET;

@Controller
@RequestMapping("/")
public class SiteController {

	@RequestMapping(method = GET)
	public String index() {
		return "index";
	}
}
\end{lstlisting}

Observe que esse controller contém duas annotations~\cite{annotations}:

\begin{itemize}
  \item \textbf{@Controller:} Indica que a classe será um controller do Spring
  MVC
  \item \textbf{@RequestMapping:} Indica que a partir da URL ``/'', esse
  controller irá atender.
\end{itemize}

Além disso, o método \lstinline{index} também está anotado com um
\lstinline{@RequestMapping}, porém, diferente da annotation da classe que recebe
uma string como valor, essa contém um atributo \lstinline{method} com o valor
\lstinline{GET}. Isso significa que, se a requisição for para a ``/'' e o método
de requisição do HTTP~\cite{requestmethod} for GET, esse método será atendido.\\

Além disso, observe que esse método retorna uma String com o valor ``index'',
isso significa que o Spring MVC tentará encontrar uma página dentro do projeto
no diretório \textbf{src/main/webapp/WEB-INF/views} com a extensão .jsp conforme
a configuração do arquivo spring-mvc.xml~\ref{lst:spring-mvc.xml_completo_da_app}

\subsection{Services do Spring}
\label{subsec:services_do_spring}

Na arquitetura MVC o controller é o responsável em receber as informações do
cliente, e então, delegar para um especialista, ou seja, uma classe capaz de
realizar a tarefa solicitada. Teoricamente, se ele receber uma requisição para
cadastrar algum objeto, significa que ele precisa passar a diante para uma
classe que faça a persistência de dados, ou então, se a requisição é para apenas
validar dados, enviará para uma classe que faça isso.\\

Mesmo sendo funcional, tal prática dentro de um controller não é recomendável,
justamente pelo controller ser responsável em apenas delegar. Em outras
palavras, controllers não se comunicam diretamente com essas classes
específicas, e sim, delegam tais tarefas para classes conhecidas como services.
Dentro do Spring, os services são basicamente uma camada que fica entre a parte
lógica (persistência de dados, validação, tratamento e geral) e o controller
para resolver qualquer tipo de requição para uma entidade, por exemplo, se é
necessário cadastrar uma turma, ou até mesmo validá-la, enviamos tal
requisição para um service que conterá todas as funcionalidades da entidade
turma.\\

No Spring, para criarmos um service, seguimos a seguinte convenção:
\textit{NomeDaClasseService}, ou seja, o nome da
classe junto com o prefixo ~\textit{Service}. Nesse projeto, todas as services
foram adicionadas no pacote \textbf{br.com.gostoudadaula.service}. Como exemplo,
veremos o service \lstinline{TurmaService} a partir do
código~\ref{lst:turma_service},que representa um service exclusivo da entidade turma:

\begin{lstlisting}[caption={código da classe TurmaController},
label={lst:turma_service}]	
package br.com.gostoudaaula.service;

import javax.inject.Inject;

import org.springframework.stereotype.Service;

import br.com.gostoudaaula.db.repository.TurmaRepository;
import br.com.gostoudaaula.model.Turma;

@Service
public class TurmaService {

	private TurmaRepository repository;

	@Inject
	public TurmaService(TurmaRepository repository) {
		this.repository = repository;
	}

	public void salva(Turma turma) {
		repository.save(turma);
	}

	public Turma retorna(Turma turma) {
		return repository.findOne(turma.getId());
	}

}
\end{lstlisting}

Além do nome da classe ter o prefixo \textit{Service}, observe que também
precisamos adicionar a annotation \lstinline{@Service} para indicar ao Spring
que essa classe será gerenciada por ele como um service. 
