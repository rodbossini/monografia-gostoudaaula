\chapter{Projeto Técnico}
\label{cap:projet/home/alex-felipe/git/monografia-gostoudaaula/cap-conceitos-e-tecnologia.texo_tecnico}

\section{Modelagem de banco de dados}
\label{sec:modelagem_de_banco_de_dados}

A aplicação \emph{Gostou da Aula?} teve seu desenvolvimento iniciado pela
modelagem conceitual dos dados. Após análise detalhada, obtivemos um Diagrama
Entidade Relacionamento, o qual é exibido pela figura ~\ref{fig:der}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{DER.jpg}
  \caption{Diagrama Entidade Relacionamento - DER}
  \label{fig:der}.
\end{figure}

Cada entitidade e relacionamento possui determinadas peculiaridades que são
descritas a seguir:

\begin{itemize}
  \item \textbf{Usuário}: Refere a uma representação de um usuário qualquer no
  sistema, essa é uma entidade abstrata, ou seja, exige uma especilização entre
  a entidade \textbf{Professor} e \textbf{Aluno} que são os 2 tipos de usuários
  existentes na aplicação.
  \item \textbf{Professor}: Representa um professor dentro da aplicação.
  \item \textbf{Aluno}: Representa um aluno dentro da aplicação.
  \item \textbf{Aula}: Representa uma aula dentro da aplicação, é constituída
  por \textbf{Aluno(os)}, um \textbf{Professor} e um \textbf{Periodo}.
  \item \textbf{Periodo}: Representa um período letivo dentro da instituição, é
  constituído por uma \textbf{Disciplina} e uma \textbf{Turma}.
  \item \textbf{Turma}: Representa uma turma da instituição.
  \item \textbf{Disciplina}: Representa uma disciplina da instituição.
  \item \textbf{Avaliacao}: Representa uma avaliação dentro da aplicação, é
  constituída por uma \textbf{Aula}, um \textbf{Projeto} e
  \textbf{Resposta(as)}.
  \item \textbf{Projeto}: Representa um projeto dentro da aplicação constituído
  por \textbf{Questoes} das avaliações.
  \item \textbf{Questoes}: Representa todas as questões de um determinado
  \textbf{Projeto}.
  \textbf{Respostas}: Representa todas as respostas de \textbf{Questoes} e
  \textbf{Avaliacao}.
\end{itemize} 

\section{Criação do projeto via Maven}
\label{sec:cricao_do_projeto_via_maven}

Para a criação do projeto, foi utilizada a biblioteca do
Maven~\ref{subsec:maven}. Há diversos modos para a criação de um projeto
utilizando a biblioteca do Maven, como por exemplo o terminal, porém, para essa
aplicação foi utilizado o Eclipse IDE~\ref{subsec:eclipse_ide_for_java_ee}, pois
ele já contém algumas facilidades, como por exemplo, escolher os menus de
criação em um modo gráfico e simplesmente digitar as informações necessárias sem
ao menos ficar escrevendo vários comandos. \ 

Para criar um projeto Maven no eclipse, basta clicar no menu ``File > New >
Project\ldots'', então aparecerá a janela conforme a figura
~\ref{fig:projeto_filtro_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project1.png}
  \caption{filtrando projetos com ``Maven'' no Eclipse IDE}
  \label{fig:projeto_filtro_maven}.
\end{figure}

Então escolhemos a opção ``Maven Project'' que exibe a janela conforme a
figura~\ref{fig:projeto_criacao_maven}:

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project2.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_criacao_maven}.
\end{figure}

Lembre-se de deixar marcada a opção ``Create a simple project (skip archetype
selection)'' justamente para avançar o passo em que seleciona o archetype do
Maven~\cite{archetype} que é descrito com mais detalhes no link disponibilizado
na bibliografia.Então clicamos em ``Next'' e aparece a janela de acordo com 
a figura~\ref{fig:projeto_informacoes_maven} :

\begin{figure}[H]
  \centering 
  \includegraphics[width=\textwidth]{creating_maven_project3.png}
  \caption{Opções para criação de um projeto Maven no Eclipse IDE}
  \label{fig:projeto_informacoes_maven}.
\end{figure}

Observe que agora é necessário adicionar algumas informações do Maven, que é
justamente o \textit{\textbf{Group Id}}, \textit{\textbf{Artifact Id}},
\textit{\textbf{Version}} e \textit{\textbf{Package}}. Cada uma das informações
possuem uma grande importante para aplicação. As descrições de cada um desses
itens estão disponíveis com detalhes no link disponibilizado na
bibliografia~\cite{namingmaven}.

Após a criação, o projeto Maven padrão criado pelo Eclipse contém a estrutura de
acordo com a figura~\ref{fig:projeto_maven_padrao}.

\begin{figure}[H]
  \centering 
  \includegraphics[width=0.7\textwidth]{project_explorer_for_maven.png}
  \caption{Estrutura do projeto Maven padrão criado pelo Eclipse}
  \label{fig:projeto_maven_padrao}.
\end{figure}

Basicamente, o diretório \textbf{src} é o local onde colocaremos todos os
arquivos fonte do projeto, como por exemplo, código, properties ou
qualquer arquivo de recurso da aplicação. Podemos observar que a estrutura
desse diretório contém mais dois subdiretórios: \textbf{main} e
\textbf{test}. Cada um desses subdiretório possuem objetivos e escopos
diferentes, que são descritos a seguir:

\begin{itemize}
  \item \textbf{main}: Todos os arquivos principais da aplicação, isto é,
  qualquer implementação destinada à aplicação, serão adicionados dentro desse
  diretório.
  \item \textbf{test}: Todos os arquivos de teste da aplicação, em outras
  palavras, qualquer tipo de código para realizar os testes da aplicação.
\end{itemize}

Além desses dois diretórios, para cada um deles, existem os subdiretórios
\textbf{java} e \textbf{resources} com os seguintes objetos:

\begin{itemize}
  \item \textbf{java}: Todos os arquivos de extensão .java, em outras palavras,
  todo código relacionado à classes Java, serão adicionados dentro desse
  diretório.
  \item \textbf{resources}: Todos os recursos da aplicação, como por exemplo,
  configurações em XML, .properties ou qualquer tipo de recurso para a aplicação
  que seja diferente de um arquivo de extensão .java, será adicionado nesse
  diretório.
\end{itemize}

\subsection{Utilizando modulos com Maven}
\label{subsec:utilizando_modulos_com_maven}

A arquitetura para o desenvolvimento da aplicação, foi planejado com a ideia da
criação de módulos~\ref{subsubsec:modularizacao_de_projeto}. Para essa aplicação
foram criados 3 módulos:

\begin{itemize}
  \item \textbf{core}: Adicionar as classes de regra de negócio representadas
  no diagrama de classes~\ref{sec:diagrama_de_classes}.
  \item \textbf{db}: Todas as classes para conexão com o banco de dados.
  \item \textbf{web}: Todas as classes e configuração para aplicação Web e
  configuração de conexão ao banco de dados.
\end{itemize}

Tendo conhecimento que cada projeto é independente um do outro, um dos pontos
importantes é saber como eles se comunicam entre eles. No Maven, utilizamos o
conceito Parent e childs descritos~\ref{subsec:parent_e_childs_com_maven}.

\subsection{Parent e childs com Maven}
\label{subsec:parent_e_childs_com_maven}

O conceito de parent e childs do Maven é justamente criar um projeto pai
(parent) e seus filhos (childs). O projeto pai, é um projeto genérico que não
possui código fonto ou qualquer arquivo de configuração. Ele é utilizado como
\textit{container} de seus filhos que de fato, são os módulos da aplicação.
Paara essa aplicação utilizamos também o mesmo nome de projeto para o parent,
porém com o sufixo \textbf{parent}.\\

Para configurar um projeto parent, simplesmente adicionamos os módulos no
pom.xml conforme o código~\ref{lst:adicao_de_modulos}:

\begin{lstlisting}[caption = {Adicionando módulos no projeto parent}, label
={lst:adicao_de_modulos}] 
	<modules>
		<module>
			gostoudaaula-core
		</module>
		<module>
			gostoudaaula-web
		</module>
		<module>gostoudaaula-db</module>
	</modules>
\end{lstlisting}

Além de informar ao parent quais são os seus módulos, todos os filhos precisam
também informar quem é o pai deles dentro do pom.xml adicionando o código:

\begin{lstlisting}[caption = {Adicionando o parent dentro de um módulo},
label={lst:adicao_de_parent}]
	<parent>
		<groupId>br.com.gostoudaaula</groupId>
		<artifactId>gostoudaaula-parent</artifactId>
		<version>0.1.9-SNAPSHOT</version>
	</parent>
\end{lstlisting}

A partir do momento em que um projeto Maven declara quem é o seu pai, todos os
recursos e dependências do pai são herdados a ele, ou seja, suas dependências e
arquivos de configurações. Porém, mesmo os modulos sendo filhos do mesmo pai,
não significa que cada um tem acesso direto ao outro, para resolver isso basta
adicionar os módulos necessários em cada projeto como uma
dependência~\ref{subsubsec:gerenciamento_de_dependencia}.




\section{Dependências de todos os módulos}
\label{sec:dependencias_de_todos_os_modulos}

Uma das grandes vantagens em utilizar o Maven é justamente pelo gerenciamento de
dependência~\ref{subsubsec:gerenciamento_de_dependencia}. Visto na
subseção~\ref{subsec:utilizando_modulos_com_maven}, a aplicação é baseada em
módulos que representam um projeto independemente, logo, cada um desses projetos possuem
suas respectivas dependências, e serão disponibilizadas a seguir:

\begin{itemize}
  \item \textbf{parent}~\ref{lst:dependencias_parent}:
  \begin{lstlisting}[caption = {Dependências do parent}, label =
  {lst:dependencias_parent}] 
  	<dependencies>
		<!-- Teste -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.hamcrest</groupId>
			<artifactId>hamcrest-core</artifactId>
			<version>1.3</version>
			<scope>test</scope>
		</dependency>

		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
			<optional>true</optional>
		</dependency>

		<!-- data -->
		<dependency>
			<groupId>joda-time</groupId>
			<artifactId>joda-time</artifactId>
			<version>2.9</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{core}~\ref{lst:dependencias_core}: 
  \begin{lstlisting}[caption = {Dependências do core}, label =
  {lst:dependencias_core}]
  	<dependencies>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>


		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<optional>true</optional>
			<scope>compile</scope>
		</dependency>

		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt</artifactId>
			<version>1.9.2</version>
		</dependency>

	</dependencies>  
  \end{lstlisting}
  \item \textbf{db}~\ref{lst:dependencias_db}:
  \begin{lstlisting}[caption = {Dependências do db}, label =
  {lst:dependencias_db}]
  	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>

		<!-- Spring data -->
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-jpa</artifactId>
			<version>1.9.2.RELEASE</version>
		</dependency>

	</dependencies>
  \end{lstlisting}
  \item \textbf{web}~\ref{lst:dependencias_web}:
  \begin{lstlisting}[caption = {Dependências do web}, label = {lst:dependencias_web}] 
  	<dependencies>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-core</artifactId>
			<version>${project.version}</version>
		</dependency>
		<dependency>
			<groupId>${project.groupId}</groupId>
			<artifactId>gostoudaaula-db</artifactId>
			<version>${project.version}</version>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<version>9.2-1003-jdbc4</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.25</version>
		</dependency>

		<!-- Básicas -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>jstl</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
			<groupId>xml-apis</groupId>
			<artifactId>xml-apis</artifactId>
			<version>1.4.01</version>
		</dependency>

		<!-- Banco de dados -->
		<!-- Migration -->
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
			<version>3.2.1</version>
		</dependency>
		<!-- ORM -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<!-- Connection Provider -->
		<dependency>
			<groupId>com.zaxxer</groupId>
			<artifactId>HikariCP</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-hikaricp</artifactId>
			<version>${hibernate.version}</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>${hibernate.version}</version>
		</dependency>


		<!-- Bean Validation -->
		<dependency>
			<groupId>javax.validation</groupId>
			<artifactId>validation-api</artifactId>
			<version>1.1.0.Final</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.2.1.Final</version>
		</dependency>

		<!-- Spring MVC -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${spring.version}</version>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>

		<!-- Gerais -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.4</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-email</artifactId>
			<version>1.4</version>
		</dependency>
		<dependency>
			<groupId>commons-codec</groupId>
			<artifactId>commons-codec</artifactId>
			<version>1.10</version>
		</dependency>
		<dependency>
			<groupId>net.sargue</groupId>
			<artifactId>java-time-jsptags</artifactId>
			<version>1.0.0</version>
		</dependency>

		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-annotations</artifactId>
			<version>2.6.3</version>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.dataformat</groupId>
			<artifactId>jackson-dataformat-xml</artifactId>
			<version>2.6.3</version>
		</dependency>
	</dependencies>  
  \end{lstlisting}
\end{itemize}

\section{Diagramas de UML utilizados} 
\label{sec:diagramas_de_uml_utilizados}

No planejamento para a implementação da aplicação, utilizamos a
UML~\ref{subsec:uml} para representar de uma forma mais clara o que tinha que
ser implementado dentro da aplicação. Dentre os diversos diagramas existentes da
UML, foram utilizados apenas os diagramas de
\textbf{classes}~\ref{subsec:diagrama_de_classes_utilizado},\textbf{caso de
uso}~\ref{subsec:diagrama_de_caso_de_uso_utilizado} e de \textbf{sequência}.

\subsection{Diagrama de classes utilizado}
\label{subsec:diagrama_de_classes_utilizado}

Em projetos de aplicações orientadas a objetos, antes mesmo de começar a
implementar as classes, é muito comum utilizarmos o diagrama de
classes~\ref{subsubsec:diagrama_de_classes} para uma visibilidade estática de
como devemos implementar as classes.
Para essa aplicação utilizamos o diagrama de classe conforme a figura~\ref{fig:diagrama_de_classes}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_classes.png}
  \caption{Diagrama de classes}
  \label{fig:diagrama_de_classes}.
\end{figure}

\subsection{Diagrama de caso de uso utilizado}
\label{subsec:diagrama_de_caso_de_uso_utilizado}

Além do diagrama de classe~\ref{subsec:diagrama_de_classes_utilizado}, é de
grande importância utilizarmos o diagrama de caso de
uso~\ref{subsubsec:diagrama_de_caso_de_uso} para obtermos uma visão macro sobre
as principais funcionalidades. Para essa aplicação, utilizamos o diagrama
conforme a figura~\ref{fig:diagrama_de_caso_de_uso}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_caso_de_uso.png}
  \caption{Diagrama de caso de uso}
  \label{fig:diagrama_de_caso_de_uso}.
\end{figure}

\subsection{Diagrama de sequência utilizado}
\label{subsec:diagrama_de_sequencia_utilizado}

Dentre as funcionalidades apresentadas no diagrama de caso de
uso~\ref{fig:diagrama_de_caso_de_uso}, a principal funcionalidade é a
\textbf{avaliar aula} que possui diversos passos para que seja realizada, porém,
para especificar tal funcionalidade utilizamos o diagrama de
sequência~\ref{subsubsec:diagrama_de_sequencia} conforme a
figura~\ref{fig:diagrama_de_sequencia}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrama_de_sequencia.png}
  \caption{Diagrama de sequência para a funcionalidade \textbf{avaliar aula}}
  \label{fig:diagrama_de_sequencia}.
\end{figure}

\section{Configurando projeto web}
\label{sec:configurando_projeto_web}

O projeto web foi baseado na estrutura do Spring
MVC~\ref{subsec:spring_framework}, porém, a configuração inicial é realizada
dentro do arquivo ``src/main/webapp/views/web.xml'' que refere-se ao arquivo de
configuração da estrutura de um projeto Java Web. Dentro desse arquivo temos a
capacidade de configurar diversos comportamentos da aplicação, como por exemplo,
quais Servlets~\ref{subsec:servlet_api} serão utilizadas, qual endereço HTTP
será atendido dentre outras recursos. Para esse projeto foi utilizado o seguinte
XML~\ref{lst:web.xml_app_web} de configuração:

\begin{lstlisting}[caption={web.xml completo da aplicação web},
label={lst:web.xml_app_web}]
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://java.sun.com/xml/ns/javaee"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
	version="3.0">
	<display-name>gostou da aula?</display-name>

	<servlet>
        <servlet-name>spring mvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <multipart-config>
            <max-file-size>500</max-file-size>
            <max-request-size>1000</max-request-size>
        </multipart-config>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring mvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>
\end{lstlisting}

Essa configuração descreve qual será a Servlet do Spring que será utilizada,
juntamente com a localização dessa Servlet. Além disso, descreve a partir de
qual endereço o Spring atuará, nesse caso, pra todo endereço que fizer parte da
``/'' (qualquer endereço via HTTP) será atendido pelo Spring, por fim, a
configuração de encoding que é justamente a formatação dos caracteres, para esse
projeto foi utilizado o UTF-8.\\

Com o arquivo web.xml configurado, precisamos criar o arquivo de configuração do
próprio Spring, que atuará como o projeto Spring MVC. Como visto no
código~\ref{lst:web.xml_app_web} a localização e nome do arquivo corresponde ao
seguinte valor: \textbf{classpath:spring/spring-mvc.xml}. Isso significa que
esse arquivo será procurado dentro do diretório:
``src/main/resources/spring/'', então criamos o arquivo \textbf{spring-mvc.xml}
com o conteúdo de acordo com o código:

\begin{lstlisting}[caption={spring-mvc.xml completo da aplicação web},
label={lst:spring-mvc.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc
	http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd 
	http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<mvc:annotation-driven />

	<mvc:default-servlet-handler />
	<context:property-placeholder
		file-encoding="UTF-8"
		location="classpath:properties/general.properties, classpath:properties/database.properties,
	 classpath:properties/flyway.properties, classpath:properties/jpa.properties" />
	<context:component-scan base-package="br.com.gostoudaaula" />

	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>

	<import resource="spring-jpa-config.xml" />
	<import resource="spring-flyway-config.xml" />
	<import resource="spring-ioc.xml" />
	<import resource="spring-i18n-config.xml" />
</beans>
\end{lstlisting}

O arquivo spring-mvc.xml concentra todas as configuração relacionadas ao Spring
MVC, como por exemplo o código~\ref{lst:configurando_mapeamento_de_paginas}:

\begin{lstlisting}[caption={configuração para o Spring mapear e acessar as
páginas web com extensões .jsp~\cite{jsp}},
label={lst:configurando_mapeamento_de_paginas}]
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
\end{lstlisting}
 
Além das configurações do Spring MVC, foram adicionadas as demais condigurações,
como injeção de dependência~\ref{subsec:injecao_de_dependencia} do Spring
Framework, JPA~\ref{subsec:jpa_java_persistence_api} e
Hibernate~\ref{subsec:hibernate} e mensageria. Cada configuração está contida em
arquivos distintos que dentro do mesmo diretório do arquivo spring-mvc.xml. Abaixo serão
listado os arquivos com suas finalidades e sua configuração:

\begin{itemize}
  \item \textbf{spring-jpa-config.xml}: Nesse arquivo contém todas as
  configurações relacionadas à configuração da JPA por meio da implementação do
  hibernate e o HikariCP~\ref{subsec:hikari_cp}. Toda a configuração está
  descrita no código:
  \begin{lstlisting}[caption={spring-jpa-config.xml completo da aplicação web},
  label={lst:spring-jpa-config.xml_completo_da_app}]
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
 http://www.springframework.org/schema/tx
 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
     http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

	<tx:annotation-driven transaction-manager="jpaTransactionManager" />

	<bean id="hibernateJpaVendorAdapter"
		class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter" />

	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
		depends-on="flyway">

		<property name="persistenceUnitName" value="${jpa.persistenceUnitName}" />
		<property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter" />
		<property name="packagesToScan" value="${jpa.packagesToScan}" />

		<property name="jpaPropertyMap">
			<map>
				<entry key="hibernate.dialect" value="${hibernate.dialect}" />
				<entry key="hibernate.enable_lazy_load_no_trans" value="true" />

				<entry key="hibernate.show_sql" value="${hibernate.show_sql}" />
				<entry key="hibernate.format_sql" value="${hibernate.format_sql}" />

				<entry key="hibernate.connection.provider_class" value="${hibernate.connection.provider.class}" />
				<entry key="hibernate.hikari.dataSourceClassName" value="${hikari.datasource.class}" />
				<entry key="hibernate.hikari.dataSource.user" value="${hikari.datasource.user}" />
				<entry key="hibernate.hikari.dataSource.password" value="${hikari.datasource.password}" />
				<entry key="hibernate.hikari.dataSource.url" value="${hikari.datasource.url}" />

				<entry key="hibernate.hikari.maximumPoolSize" value="${hikari.pool.maxSize}" />
				<entry key="hibernate.hikari.connectionTimeout" value="${hikari.pool.timeOut}" />
				<entry key="hibernate.hikari.poolName" value="${hikari.pool.name}" />

				<entry key="hibernate.hikari.dataSource.cachePrepStmts" value="${hikari.ds.cache.prepStmts}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSize"
					value="${hikari.ds.cache.size}" />
				<entry key="hibernate.hikari.dataSource.prepStmtCacheSqlLimit"
					value="${hikari.ds.cache.sqlLimit}" />
				<entry key="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy" />
			</map>
		</property>
	</bean>

	<bean id="jpaTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	<!-- configuração do spring data -->
	<jpa:repositories base-package="br.com.gostoudaaula.db"
		entity-manager-factory-ref="entityManagerFactory"
		transaction-manager-ref="jpaTransactionManager" 
		/>
</beans>
  \end{lstlisting}
\end{itemize}





